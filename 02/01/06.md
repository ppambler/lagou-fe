### ✍️ Tangxt ⏳ 2021-10-26 🏷️ 工程化

# 06-自动化构建简介、自动化构建初体验、常用的自动化构建工具

## ★自动化构建简介

![自动化构建](assets/img/2021-10-26-10-37-32.png)

自动化构建是前端工程化当中一个非常重要的组成部分。

### <mark>1）「自动化」与「构建」</mark>

在具体学习之前，我们先来解读一下这一个开发行业当中经常提及的名词。

![自动化构建](assets/img/2021-10-26-10-47-00.png)

自动化实际上指的就是我们通过机器去代替手工完成一些工作。

构建 -> 你可以把它理解成转换，就是把一个东西转换成另外的一些东西。

### <mark>2）「自动化构建工作流」是什么？</mark>

总的来说，开发行业当中的自动化构建，就是把我们开发阶段写出来的源代码，自动化的去转换成生产环境当中可以运行的代码或者程序。

![自动化工具流](assets/img/2021-10-26-10-48-58.png)

一般我们会把这样一个转换的过程称之为「**自动化构建工作流**」。

### <mark>3）「自动化构建工作流」的作用？</mark>

![作用](assets/img/2021-10-26-10-51-02.png)

它的作用就是让我们尽可能去脱离（离开；断绝）运行环境的种种问题，去在开发阶段去**使用一些提高效率的语法规范和标准**。

![规范和标准](assets/img/2021-10-26-10-52-23.png)

这最典型的应用场景就是我们在去开发网页应用时，我们就可以：

![开发](assets/img/2021-10-26-10-53-57.png)

- 使用 ECMAScript 的最新标准去提高编码效率和质量
- 利用 Sass 去增强 CSS 的可编程性
- 然后再去借助模板引擎去抽象页面当中重复的 HTML

### <mark>4）为什么需要「自动化构建工具」？</mark>

![不被支持](assets/img/2021-10-26-10-54-42.png)

然而这一些用法在浏览器当中是没有办法直接被支持的。

那在这种情况下，自动化构建工具就可以派上用场了。

![自动化构建工具](assets/img/2021-10-26-10-56-06.png)

我们通过自动化构建的方式将这些不被支持的代码「**特性**」转换成能够直接运行的代码 -> 这样我们就可以在进行我们的开发过程当中，通过这些方式去提高我们编码效率了。

## ★自动化构建初体验

![初体验](assets/img/2021-10-26-11-34-38.png)

接下来我们通过一个小案例来体会一下自动化构建的便捷之处。

### <mark>1）不想用写 CSS 的方式去完成网页的样式</mark>

在这个案例中，我们一开始使用的是直接编写 CSS 的方式去完成网页的样式：

![CSS](assets/img/2021-10-26-13-25-17.png)

但是我们希望通过 Sass 去增强 CSS 的编程性 -> 这具体的实现方式就是在开发时我们添加一个构建的环节，这样让我们在开发环节就可以通过 CSS 编写样式，再通过工具将 Sass 去构建为 CSS

![Sass](assets/img/2021-10-26-13-26-53.png)

> 一般来说有 Less、Sass 这两种预处理器，Sass 后来受 Less 影响也发布了接近 CSS 块语法的 Scss -> `.scss`文件是接近 CSS 语法，即在`{}`写样式属性，而`.sass`文件则是用缩进来表示样式属性属于某个选择器 -> 总之，Sass 有两种语法格式！ -> 一般我们选择用 SCSS（Sassy CSS）这样语法格式，因为它是在 CSS3 语法的基础上进行拓展的，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能

接下来我们具体来看如何操作。

### <mark>2）我想用 Sass 来写网页的样式</mark>

💡：删掉原先的`.css`文件

我们回到 VS Code 当中。我已经准备好了一个使用 CSS 完成网页样式的一个小案例：

![CSS 文件](assets/img/2021-10-26-13-41-19.png)

此时我们就不需要 CSS 文件了，我们把该 CSS 文件删除

💡：添加`.scss`文件

取而代之的就是新建一个 Sass 文件：

![Sass 文件](assets/img/2021-10-26-13-59-55.png)

在这个 Sass 文件当中，我们就可以按照 Sass 的语法去编写我们的网页样式，相对于 CSS， **Sass 的编程能力肯定是要更强一些**。但是 Sass 它并不能在我们的浏览器环境当中直接去使用。所以说我们需要在开发阶段通过一个工具去把它转换成 CSS -> 这里我们要使用的就是 Sass 官方提供的一个 Sass 模块，我们可以进入命令行，通过`yarn add sass`这个模块。但是需要注意 -> 我们把它作为一个开发依赖来安装`--dev`。

💡：安装 `sass`，用它来把`.scss`文件编译成`.css`文件

![安装 sass](assets/img/2021-10-26-14-05-11.png)

💡：查看`sass`命令在哪儿？

安装完成过后，我们在`node_modules`下面就会出现一个`.bin` 的目录 -> 这个目录下就会有一个 Sass 的命令文件：

![sass](assets/img/2021-10-26-14-06-29.png)

💡：查看`sass`命令需要什么参数？

我们在命令行当中就可以通过路径找到这个命令。执行完这个命令，它会打印出来一些帮助信息：

![--help](assets/img/2021-10-26-14-08-10.png)

在这个帮助信息的一开始，它就给出来了这个命令的具体用法 -> 这具体就是我们需要指定一个 Sass 的输入路径以及一个 CSS 的输出路径。那我们这儿就是`scss/main.scss`，而输出路径是 `css/style.css`

💡：再次执行`sass`命令

![启动 sass](assets/img/2021-10-26-14-12-06.png)

再次执行，它就可以自动的去帮我们把我们的 Sass 文件转换成 CSS 了，不仅如此，它还帮我们添加了对应的 `sourceMap` 文件 -> 这样的话，我们在调试阶段就可以定位到我们的源代码当中的位置了。

但是这样也有一个比较麻烦的地方，那就是我们每次都需要重复的去输入这些复杂的命令。而且在别人接手你的项目过后，他也不知道该如何去运行这些构建的任务 -> 所以说我们**需要做一些额外的事情去解决这些在项目开发阶段重复去执行的命令**。

### <mark>3）NPM Scripts</mark>

![NPM Scripts](assets/img/2021-10-26-14-13-16.png)

NPM Scripts 主要就是用来解决这个问题的，你可以在 npm 的 `scripts` 当中去定义一些与这个项目开发过程有关的一些脚本命令 -> 这样一来，你就可以让这些命令跟着项目一起去维护 -> 这便于我们在后期开发过程当中的使用。

所以说我们这儿最好的方式就是通过 NPM Scripts 方式去包装你的构建命令。

#### <mark>1、添加`scripts`字段</mark>

具体的实现方式就是在我们的`package.json`当中去添加一个 `scripts` 字段 -> 这个字段是一个对象，键就是 `script` 的名称，值是我们需要去执行的命令 -> 这里需要注意的是 script 它可以自动去发现`node_modules`里面的命令，所以说我们就不需要写完整的路径，直接使用命令的名称就可以了。

![定义 scripts](assets/img/2021-10-26-14-17-04.png)

#### <mark>2、用`yarn`启动`build`脚本</mark>

完成过后，我们就可以通过 `npm` 或者 `yarn` 去启动这个 script -> `npm` 当中需要去运行 `npm run script-名称`，而`yarn`当中可以去省略这个 `run`：

![yarn build](assets/img/2021-10-26-14-18-56.png)

### <mark>4）用 NPM Scripts 实现自动化构建</mark>

另外，NPM Scripts 也是**实现自动化构建最简单的方式**。

接下来我们就一起再来看一下如何通过它去实现自动化构建。

#### <mark>1、安装 `browser-sync`</mark>

我们这里为项目再去安装一个叫做`browser-sync`的模块（没有热更新，修改文件得自己手动刷新页面），用于去启动一个测试服务器去运行我们的项目：

![browser-sync](assets/img/2021-10-26-14-22-06.png)

#### <mark>2、添加 `serve` 命令</mark>

这个时候我们在 scripts 当中去添加一个叫做 `serve` 的命令。在这个命令当中，通过 `browser-sync` 把当前这个目录给它运行起来 -> 回到命令行，我们运行一下 `serve` 命令

![启动 web 服务器](assets/img/2021-10-26-14-26-45.png)

此时 `browser-sync`会自动启动一个 web 服务器，并且帮我们唤起浏览器，运行我们当前这个网页。

#### <mark>3、为什么需要添加 `preserve` 命令？</mark>

但是，如果说在 `browser-sync` 工作之前，我们并没有去生成我们的样式：

![没有样式](assets/img/2021-10-26-14-29-32.png)

那此时 `browser-sync` 工作的时候，我们页面就没有样式文件了，**所以我们需要在启动 `serve` 命令之前去让 `build` 任务去工作**。

#### <mark>4、添加 `preserve` 命令</mark>

![preserve](assets/img/2021-10-26-14-32-32.png)

所以我们这儿可以借助于 NPM Scripts 的钩子机制去定义一个 `preserve` -> 它会自动在 `serve` 命令执行之前去执行 -> 这个时候你再去执行 `serve` 它就会自动化的先去执行 `build` 命令 -> `build` 完成过后再去执行对应的 `serve`

此时我们就可以完成在启动 web 服务之前，自动去构建我们的 Sass 文件。

#### <mark>5、为`sass`命令添加`--watch` & 为什么要安装 `npm-run-all`？</mark>

当然，光有这些还不够，我们还可以为`sass`命令去添加一个`--watch` 的参数 -> 有了这个参数过后，Sass 在工作时就会监听文件的变化。一旦当我们代码当中的 Sass 文件发生改变，它就会自动被编译。

![--watch](assets/img/2021-10-26-14-44-49.png)

这时候我们回到命令行重新运行之前的命令。

你会发现 Sass 命令在工作时，命令行会阻塞在这个地方去等待文件的变化

那这样就导致了我们后面的 `browser-sync` 它并没有办法直接去工作 -> 这种情况下我们就需要**同时去执行多个任务**。

#### <mark>6、安装 `npm-run-all` 模块</mark>

我们这里可以借助于`npm-run-all`这个模块去实现，我们需要先安装一下这个模块：

``` bash
yarn add npm-run-all --dev
```

![npm-run-all](assets/img/2021-10-26-14-46-35.png)

#### <mark>7、添加 `start` 命令</mark>

有了这个模块过后，我们就可以在 `scripts` 当中，再去添加一个新的命令，这个命令我们把它叫做 `start` 

在这个命令当中，我们通过 `npm-run-all` 里面的`run-p`这个命令同时去执行 `build` 和 `serve` 命令。

#### <mark>8、运行 `start` 命令</mark>

此时我们回到命令行当中，我们再去运行一下这个 `start` 命令。

![同时执行](assets/img/2021-10-26-14-51-09.png)

那这个时候你就会发现 `build` 任务和 `browser-sync`任务同时被执行了。

我们可以尝试的去打开 Sass 文件去修改 Sass 文件里面的内容 -> 这个时候你会发现 CSS 文件也会跟着一起去变化，这也就证明我们的 watch 已经生效了。

#### <mark>9、为 `browser-sync` 添加 `--files` 参数（热更新）</mark>

![--files](assets/img/2021-10-26-15-02-20.png)

最后我们还可以给`browser-sync`这个命令去添加一个`--files`参数 -> 这个参数可以让`browser-sync`在启动过后去**监听项目下的一些文件的变化** -> 一旦当文件发生变化过后，`browser-sync` 会将这些文件的内容**自动同步到浏览器，从而更新浏览器当中的界面，让我们可以即时（立即，当下；立刻）查看到最新的界面效果**。

那这样就避免了我们修改完代码过后再去手动刷新浏览器这样一个重复的工作

#### <mark>10、总结</mark>

这样一来，我们就借助于 NPM Scripts 完成了一个简单的自动化构建的工作流。

而它具体的工作流程就是在启动任务（`yarn start`）过后，同时去运行了 `build` 和 `serve` 这两个命令。

其中：

- `build` 去自动监听 Sass 文件的变化去编译 Sass
- `browser-sync`它启动一个 web 服务，当文件发生变化过后，去刷新浏览器

## ★常用的自动化构建工具

![自动化构建工具](assets/img/2021-10-26-16-54-01.png)

NPM Scripts 它确实能解决一部分的自动化构建任务。但是对于相对复杂的构建过程，npm 的 `scripts` 它就显得非常吃力了。

那这时候我们就需要更为专业的构建工具。

这里我们先对市面上几个常用的自动化构建工具去做一个大致的介绍，让大家先有一个整体的认识，后面我们再去做具体的深入探究。

![Grunt Gulp FIS](assets/img/2021-10-26-16-55-04.png)

目前市面上开发者使用的最多的一些开发工具主要就是 Gulp、Grunt 和 FIS，这可能会有人问：Webpack 去哪儿了？

严格来说，Webpack 它实际上是一个模块打包工具，所以说这不在我们这一次的讨论范围之内。

这些工具它都可以去**帮你解决那些重复而且无聊的工作，从而实现自动化**。用法上他们也都大体相同，都是先通过一些简单的代码去组织一些插件的使用，然后你就可以使用这些工具去帮你执行各种各样重复的工作了。

我们依次来看。

### <mark>1）Grunt</mark>

Grunt ，它算是最早的前端构建系统了，它的插件生态非常的完善。用官方的一句话来说就是： Grunt 它的插件几乎可以帮你自动化的去完成任何你想要做的事情。

但是，由于它的工作过程是**基于临时文件去实现的**，所以说它的**构建速度相对较慢**。

例如我们使用它去完成我们项目当中 Sass 文件的构建。

那我们一般会先对 Sass 文件去做编译操作，再去自动添加一些私有属性的前缀，最后再去压缩代码。

那这样一个过程当中，Grunt 每一步都会有磁盘读写操作。你比如像 Sass 文件在编译完成过后，它就会将结果写入到一个临时的文件。然后下一个插件，它再去读取这个临时文件进行下一步。

那这样一来，你处理的环节越多，文件读写的次数也就越多 -> 这对于超大型项目当中，我们的项目文件会非常多，你的构建速度就会特别的慢。

### <mark>2）Gulp</mark>

而 Gulp 是我个人使用非常多的一个构建系统，它很好的解决了 Grunt 当中构建速度非常慢的这样一个问题，因为它是**基于内存去实现的**，也就是说它对文件的处理环节都是在内存当中完成的 -> **相对于磁盘读写，速度自然就快了很多**。

另外，它默认支持**同时去执行多个任务**，那效率自然大大提高，而且它的**使用方式相对于 Grunt 更加直观易懂**，插件生态也同样非常完善。所以说它后来居上。目前更受欢迎，应该算是目前市面上最流行的前端构建系统了。

### <mark>3）FIS</mark>

最后我们来看 FIS。

FIS 是百度的前端团队推出的一款构建系统，最早只是在他们团队内部去使用，后来开源过后在国内快速流行 -> 相对于前面两个构建系统这种微内核的特点，FIS 它更像是一种**捆绑套餐**。

它**把我们在项目当中一些典型的需求尽可能都集成在内部**了。例如我们在 FIS 当中就可以很轻松地去处理资源加载、模块化开发、代码部署甚至是性能优化。正是因为这种**大而全**，所以在国内很多项目当中就流行开了。

### <mark>4）构建工具小结</mark>

总体来说，如果你是初学者的话，可能 FIS 更适合你。但是如果你的要求**灵活多变**的话，Gulp、Grunt 应该是你更好的选择。

还是那句话：**新手是需要规则的，而老手一般都会渴望自由**。也正是因为这个原因，现在这些小而美的框架或者工具才会得以流行。

## ★了解更多

➹：[less 和 sass 或者 scss 有什么区别吗？ - 知乎](https://www.zhihu.com/question/270862074)

➹：[CSS、Sass、Scss，以及 sass 和 scss 的区别 - SegmentFault 思否](https://segmentfault.com/a/1190000019573996)

➹：[Sass 教程 Sass 中文文档 - Sass 中文网](https://www.sass.hk/docs/)