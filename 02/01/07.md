### ✍️ Tangxt ⏳ 2021-10-26 🏷️ 工程化

# 07-Grunt 的基本使用、Grunt 标记任务失败、Grunt 的配置方法、Grunt 多目标任务、Grunt 插件的使用、Grunt 常用插件及总结

## ★Grunt 的基本使用

![基本使用](assets/img/2021-10-26-19-27-47.png)

接下来我们在一个空项目当中去看一下 Grunt 的具体用法。

我们这儿是一个全新的空项目，我们在这个项目当中想要去使用 Grunt 的话，首先先需要去 `init` 一个 `package.json`。

有了这个文件过后，我们需要通过 `add` 方式去添加一下 Grunt 这个模块：

``` bash
yarn add grunt --dev
```

> 视频里没有加`--dev`

安装完这个模块过后，我们还需要在这个项目的根目录下去添加一个`gruntfile.js`文件 -> 这个文件是 Grunt 的入口文件，用于去定义一些需要 Grunt 自动去执行的任务。

我们在这个文件当中需要去导出一个函数，这个函数去接收一个叫做 `grunt` 的形式参数 -> 这个 `grunt` 它是一个对象，对象当中就是 grunt 提供的一些 API，我们可以借助于这些 API 去快速创建一些构建任务。

具体来做就是我们通过`module.exports`去导出这样一个函数。

在这个函数中，我们借助于 `grunt` 的`registerTask`方法去注册一个任务。

这个方法第一个参数去指定一下我们这个任务的名字。第二个参数可以去指定一个任务函数，也就是当这个任务发生时自动去执行的这个函数。

那我们在这个函数里面打印一个 `hello Grunt` 

我们回到命令行当中。

为了可以更清楚的看到我们的代码，我们把这个面板移到屏幕的右侧，然后运行 `yarn grunt`

`yarn`它会自动的去帮我们找到 `node_modules`当中提供的一些命令 -> 我们紧接着跟上 `foo` -> `foo`就是我们刚刚注册的这个任务的名字。

那这样的话，Grunt 就会自动的去帮我们去执行 `foo` 这个任务。当然，你不仅仅可以添加一个任务，你还可以去添加更多的任务。

如果你在添加任务的时候，你的第二个参数指定的是一个字符串的话，那这个字符串将会成为这个任务的描述，它会出现在 Grunt 的帮助信息当中。
我们可以在命令行当中，通过 `grunt --help` 去得到 Grunt 的帮助信息。

在这个帮助信息当中，有一个 `Available tasks`，在这个 `task` 当中，你的任务描述就是我们自定义的一个任务描述了。

当然，你同样可以通过 `grunt` 去运行 `bar` 这个任务 -> 具体的运行方式就是通过 `grunt bar`

除此之外，如果说你在注册任务的时候，你任务的名称叫做 `default` 的话，那这个任务将会成为 Grunt 的默认任务 -> 你在运行这个任务的时候，就不需要再去指定任务的名称，Grunt 将自动调用 `default` -> 一般我们会用 `default` 去映射一些其他的任务。

那具体的做法就是在`registerTask`这样一个方法当中，第二个参数传入一个数组 -> 这个数组当中我们可以去指定一些任务的名字，那这个时候我们去执行 `default` 的时候，Grunt 就会依次执行我们数组当中这些任务。

我们回到命令行当中，通过 Grunt 去执行默认任务。那此时你会发现 Grunt 先执行了 `foo` 这个任务，然后去执行了 `bar` 这个任务。那这样的话，`default` 就相当于是把 `foo` 和 `bar` 串联到了一起。

最后我们再来尝试了一下 Grunt 当中对异步任务的支持。

我们在这个`async-task`任务当中去通过`setTimeout`去模拟一下异步操作。

在异步任务完成过后，我们打印一个消息到控制台当中。

完成过后我们回到命令行 -> 通过 Grunt 去执行一下这个任务。

通过执行，我们发现`console.log()`并没有直接执行 -> 这个是 Grunt 当中一个特点 -> Grunt 的代码，它默认支持同步模式。

如果说你需要异步操作的话，你必须要使用`this.async`方法得到一个回调函数，在你的异步操作完成过后，去调用这个回调函数，标识一下这个任务已经被完成。

如果说我们要在函数当中使用 `this` 的话，那我们的函数就不能是箭头函数了，我们需要使用普通的函数。在这函数当中，我们使用`this.async`得到一个回调函数 -> 这一次我们在 `setTimeout` 完成过后，除了打印消息以外，我们还需要去调用一下这个 `done` 回调函数 -> 标识一下我们这个任务已经完成了 -> 此时 Grunt 就知道这是一个异步任务，它会等待 `done` 的执行，直到 `done` 被执行，Grunt 才会结束这个任务的执行。

## ★Grunt 标记任务失败

如果你在构建任务的逻辑代码当中发生错误，例如我们需要的文件找不到了，那此时我们就可以将这个任务标记为一个失败的任务。

具体的实践方式 -> 我们可以通过在函数体当中去 `return false` 来实现。

例如在我们这个`bad`任务当中，我们在最下面 `return`了`false`

那此时我们回到终端，我们尝试着运行一下这个任务。

那你会发现终端当中提示我们 `bad` 这个任务它执行失败了 -> 如果说你这个任务是在一个任务列表当中的话，那这个任务的失败会导致后续所有的任务不再被执行。

例如我们这儿有多个任务。

然后我们通过一个 `default` 任务把他们连接到一起。那么在正常情况下，我们去运行 `default` -> 它会依次去执行 `foo`、`bad`以及`bar`，但是我们这里的 `bad` 它执行失败了 -> 那这样的话，`bar` 任务就不会被执行了。

我们回到终端当中，我们尝试着去运行一下这个 `default`：

那此时你会发现 `foo` 任务和 `bad` 任务都执行了，然而`bad` 任务执行失败了，而最后这个 `bar` 也就不会被执行了 -> 而且此时命令行当中也给了我们一个提示，如果说你要去指定了一个`--force`的参数话，那此时会采用一种强制方式去执行所有的任务，我们尝试一下：

有了`--force`过后，我们 `bad` 任务即使运行失败了，后续的 `bar` 任务也是会正常去执行的。

那这就是我们如何去标记一个任务失败以及标记任务失败过后的一些影响。

但是如果说你的任务是一个异步任务的话，那异步任务当中我们就没有办法直接通过`return false` 去标记这个任务失败。

那此时我们需要给异步的回调函数指定一个`false`的实参就可以标记为这个任务失败了。

我们尝试一下：

可以看到，此时我们这一个异步任务就会被标记为一个失败的任务。

我们回到终端当中尝试着去运行一下这个任务：

``` bash
yarn grunt bad-async
```

这时候你会发现这个`bad-async`任务也是执行失败的 -> 这就是我们在 Grunt 的任务当中如何去标记此任务为一个失败的任务，以及标记为失败任务过后的一个影响。

## ★Grunt 的配置方法
