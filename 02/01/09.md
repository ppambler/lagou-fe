### ✍️ Tangxt ⏳ 2021-10-28 🏷️ 工程化

# 09-Gulp 案例 - 样式编译、Gulp 案例 - 脚本编译、Gulp 案例 - 页面模板编译、Gulp 案例 - 图片和字体文件转换、Gulp 案例 - 其他文件及文件清除、Gulp 案例 - 自动加载插件

## ★Gulp 案例 - 样式编译

![样式编译](assets/img/2021-10-28-15-13-49.png)

接下来，我们就通过一个实际的案例一起去学习一下如何使用 gulp 去完成一个网页应用的自动化构建工作流。

我已经提前在 [github](https://github.com/zce/zce-gulp-demo) 上准备好了一个需要我们完成构建工作的一个网页应用。

先把这样一个基本的结构给它克隆下来，我们通过点击`Clone or download`获取一下咱们当前这个仓库的链接，然后回到命令行当中，我们通过 `git clone` 这个地址

完成过后，我们通过 VS Code 打开这个目录。

![目录结构](assets/img/2021-10-28-16-49-57.png)

这里我们先跟大家介绍一下我之前准备的这个结构的一个大概的设想。

首先在这个里面有一个 `public` 目录 -> `public` 目录里面，就是我们在开发这个网页应用程序当中，那些不需要被加工、直接被拷贝到最终我们生成的那个文件夹的一些文件 -> 这个里面我们默认放了一个`favicon.ico`，也就是我们站点的图标。

然后，除此之外还有一个 `src` 的目录 -> 这个目录顾名思义就是放我们开发阶段所编写的一些代码的 -> 这个目录下所有的文件都会被构建，说白了，它们都会被经过转换再放到我们最终生成的那个目录下面

例如我们的 HTML 文件，我们里面是通过模板的方式去编写的：

![模板](assets/img/2021-10-28-16-57-02.png)

它可以去使用一些布局页（`layouts`目录）或者是部分页（`partials`目录）的这种概念。这就是对 HTML 的处理。

除此之外，我们还需要在这个编写样式的时候，通过 sass 的方式去完成网页的样式。

还有就是我们需要在完成网页脚本的时候，通过 ES6 方式去编写网页的脚本 -> 这个也需要在构建的过程当中去自动转换成 ES5 的实现方式。

然后，还有我们网站开发过程当中会用到的一些图片和字体文件 -> 这些文件我们需要它自动的去被压缩 -> 因为我们知道图片当中实际上是有一些二进制的元数据信息，那些信息在我们实际生产环境是没有必要的 -> 这些信息我们都可以通过自动化构建的过程把它删除掉，从而压缩图片的体积。

以上这一些就是我们这样一个网页结构下面 -> 我们对自动化的一些诉求。

有了这些诉求过后，接下来。我们就具体来去做。

首先第一件事，我们先需要在项目当中去安装这个 gulp。

我们打开命令行终端。

在终端当中，我们通过`yarn add gulp`这个模块作为开发依赖安装进来。

有了这样一个模块过后，我们就可以在项目的根目录下去新建一个 `gulpfile.js` 文件，作为我们 gulp 的入口文件 -> 我们需要在这个里面去定义一些构建任务。

刚刚我们所说的所有的构建需求我们都需要在这个文件当中去完成 -> 那我们依次来看这些构建任务如何去实现？

首先我们先在这个`gulpfile.js`里边去定义一个 `style` 任务 -> 这个任务我们先给它定义成一个私有的任务，也就是我们之前说的私有函数 -> 后续我们再通过`module.exports`去选择性的导出哪些函数。

我们让这个 `style` 等于一个普通的函数：

``` js
const style = () => {}
```

在这个函数的过程当中，我们肯定会用到 gulp 所提供的一些 API 所以我们这儿先把它们导入进来：

``` js
const { src, dest } = require('gulp')
```

`dest` 全称应该是 `destination`，也就是目标位置的意思，我们 `require` 一下 gulp 这个模块就能把这两个 API 给导入进来

有了这样两个 API 过后，我们在 `style` 这个方法里面肯定需要去 `return` 一下。 

`src` 它指定的这个文件的路径是`'src/assets/styles/*.scss'` -> 通配符叫`globs`（VS Code 有提示`src`需要什么参数）

``` js
const style = () => {
  return src('src/assets/styles/*.scss')
}
```

接着，我们需要通过这个 `src` 创建的这个读取流去 `pipe` 到我们 `dest` 去帮我们创建一个写入流 -> 这个写入，我们一般会把生成的文件放在一个叫做 `dist` 目录的地方：

``` js
const style = () => {
  return src('src/assets/styles/*.scss').pipe(dest('dist'))
}
```

注意这个`dest`和`dist`，它们俩发音很接近，但是，它们不是一个概念，我们的这个`destination`，它指的是我们目标位置的意思。而 `dist` 它指的是分发、发布，也就是说这个`dist`目录一般是用来发布的 -> 这个`dist`文件夹会在我们网页开发过程当中经常被用到，一般编译过后的结果我们放到 `dist` 当中。

这时候我们保存一下。

需要注意的是，我们的这个 `style` 它是一个私有的任务，并不能直接通过 gulp 去执行。

我们想要去测试它的话，我们需要把它导出出去。

``` js
module.exports = { style }
```

我这儿通过 `module.exports` 的方式去导出一个对象 -> 这个对象当中所有的成员都可以在外界被使用，跟我们用 `exports.xxx` 导出实际上是一样的，它们俩本身就是一个别名。

保存一下

完了过后，我们回到终端当中，我们运行一下 `style` 这个任务：

``` bash
yarn gulp style
```

此时这个 style 任务执行完成过后，我们的项目根目下会多出来一个 `dist` 目录 -> 这个`dist`目录，它里面的这些文件就是我们刚刚在 `src` 下面的关于样式`styles`这个目录下的一些文件。

这需要注意的一个问题是，我们实际上是希望它可以按照 `src` 下面的这样一个目录结构输出，而此时这个`style`任务只是按照我们匹配出来的这些文件的名字，然后直接去放到了`dist`下面 -> 那这个就丢失掉了我们原本的目录结构。

这个问题我们可以通过给`src`函数去指定一个选项参数——`base` -> 也就是在转换的时候这个基准路径是什么 -> 那基准路径是 `src`

``` js
src('src/assets/scripts/*.js', { base: 'src' })
```

这个时候，它就会把 `src/assets/styles/*.scss`的`src`后面这一系列的目录结构`assets/styles/*.scss`给它保留下来

我们再去保存一下，我们重新来去尝试一下这个任务。

``` bash
yarn gulp style
```

此时，我们在 `dist` 下面就会有`assets`下面的 `styles` 然后下面会有对应的样式文件。

那这样的话，我们这个 sass 任务的文件拷贝过程就是正常的了。

但是此时我们还没有加上这个文件的转换。

按照我们之前的了解来讲的话，转换的过程我们需要通过插件提供的一些转换流来实现。

所以说我们还需要再去安装一个插件 -> 这个插件的名字叫做`gulp-sass`，这同样也是开发依赖：

``` bash
yarn add gulp-sass --dev
```

在安装这个`gulp-sass`的时候，它内部会去安装 `node-sass`，而 `node-sass` 是一个 c++ 的模块，所以它内部会有一些对 c++ 它的那个程序集的一个依赖 -> 那这个时候，这些二次进制的包需要去通过国外的一些站点去下载，所以说这有的时候会下载不下来 -> 那你可以通过淘宝的镜像源去单独为这个 `node-sass` 配置一个镜像。

这一块安装完成过后，我们就可以去使用这样一个插件了。

我们把这个插件导入进来：

``` js
const sass = require('gulp-sass')
```

有了这个插件过后，我们在 `src` 和 `dest` 之间需要去 `pipe` 到我们的这个 `sass` 

``` js
const style = () => {
  return src('src/assets/styles/*.scss').pipe(sass()).pipe(dest('dist'))
}
```

基本上，每一个插件它提供的都是一个函数，这个函数的调用结果会返回一个文件的转换流。

那这样的话，我们就可以去实现这个文件的转换过程，我们再回到命令行重新去运行一下这个任务。

``` bash
yarn gulp style
```

此时我们再回到 `dist` 这个目录下面，我们会看到`assets/styles`下面就会有一个`main.css`

但是，之前测试，在`dist`目录下遗留的其他的这些文件`scss`文件，它们默认不会被清空掉，因为目前`style`这个任务在处理的这个过程当中，实际上是以覆盖的方式覆盖进去，而你之前那些文件它不会帮你清空掉 -> 所以，我们后续会加一些清空的任务，自动的去删除这些文件 -> 我们现在先手动去删除一下它们

删除完了过后我们重新去运行一下，这样的话就不会干扰我们的测试效果了

``` bash
yarn gulp style
```

这时候我们会发现在`dist/assets/styles`下面就会有一个`main.css`出现。

可能细心的同学会发现一个问题，我们在通过 `src` 匹配这个文件的读取的时候，它实际上读取到的是三个文件，也就是`main.scss`、`_variables.scss`、`_icons.scss`（`demo.scss`，视频里没有）这三个文件，但是输出过后只有一个文件。

这个原因是因为我们在 sass 这个模块儿工作的时候，它会认为这种**下划线开头**的这些样式文件都是我们在主文件当中依赖的一些文件，那它就不会被转换，会被忽略掉。

所以说，最终只有这种没有下划线开头的 sass 文件会被转换过去

我们也可以在这儿尝试着再给大家添加一个样式文件，如`demo.scss`

这个样式文件里面我们什么都不用做，我们就直接保存一下，然后回到终端这边我们再重新去走。

``` bash
yarn gulp style
```

这时候你就会发现我们在 `style` 当中就会多出来一个`demo.css` -> 这是一个大家可能会产生疑惑的一个小点。

关于这个 sass ，它使用就是这么简单，可能有一个需要大家额外了解一下的一个选项，就是我们在生成的这个样式的代码当中，我们 CSS 的结束的括号，也就是我们这个 CSS 的选择器结束的这个括弧`}`，它默认是出现在了最后一个属性后面。

``` css
.icon-aperture:before {
  content: '\e900'; }
```

对于这种方式，一般我们自己写代码的时候，喜欢把它放在一个空行上面：

``` css
.icon-aperture:before {
  content: '\e900';
}
```

对于这个，我们可以通过单独给这个 sass 指定一个选项`outputStyle`去完成：

``` js
const style = () => {
  return src('src/assets/styles/*.scss').pipe(sass({ outputStyle: 'expanded'})).pipe(dest('dist'))
}
```

`expanded`也就是完全展开的这种形式。

此时，它再去构建的时候，就会按照完全展开的这样一个格式，帮我们生成对应的样式代码 -> 这个是我们样式的编译任务。

除此之外，我们肯定还需要去完成脚本的编译任务和我们 HTML 的编译任务。我们待会来看。

## ★Gulp 案例 - 脚本编译

![脚本编辑](assets/img/2021-10-28-17-59-02.png)