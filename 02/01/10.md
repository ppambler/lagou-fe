### ✍️ Tangxt ⏳ 2021-10-29 🏷️ 工程化

# 10-Gulp 案例 - 开发服务器、Gulp 案例 - 监视变化以及构建优化、Gulp 案例 - useref 文件引用处理

## ★Gulp 案例 - 开发服务器

![开发服务器](assets/img/2021-10-29-14-40-26.png)

除了对文件的构建操作以外，我们这里还需要一个开发服务器，用于在开发阶段去调试我们的应用。

我们可以通过 gulp 去启动并且管理这个开发服务器。那这样的话，我们就可以在后续去配合我们其他的一些构建任务去实现「在代码修改过后自动去编译，并且自动去刷新浏览器页面」 -> 这样就会大大提高我们在开发阶段的效率，因为它会减少我们在开发阶段的重复操作。

我们具体来看怎么样去操作。

首先我们先去安装一个叫做 `browser-sync` 的一个模块：

``` bash
yarn add browser-sync --dev
```

这个`browser-sync`模块它会提供给我们一个开发服务器 -> 相对于我们普通使用 express 创建的 web 服务器来说的话，`browser-sync` 它有更强大的一些功能 -> 它支持我们在代码修改了过后，自动热更新到浏览器当中，让我们可以及时看到最新的页面效果。

有了这个模块过后，我们在 gulp 当中需要去使用一下这个模块儿。

它并不是一个 gulp 的插件，只不过我们是通过 gulp 去管理它而已。所以我们需要单独去引入一下这个模块儿。

``` js
const browserSync = require('browser-sync')
```

这个模块它提供了一个 `create` 方法，用于去创建一个服务器。

我们定义一个 `bs` 变量：

``` js
const bs = browserSync.create()
```

`create`方法它会自动去创建一个开发服务器。我们将这个开发服务器单独定义到一个任务当中去启动。

我们这定义一个 `serve` 任务。

在这个任务当中，我们通过 `bs` 的 `init` 方法去初始化一下我们这个 web 服务器的一些相关配置 -> 这个里面最核心的一个配置就是 `server` -> `server` 当中需要去指定一下我们网站的根目录，也就是我们 web 服务器它需要帮你把哪个目录作为网站的根目录

我们这通过 `baseDir` 去设置 -> 网页的根目录肯定就是 `dist` 这个目录 -> 因为 `src` 下面是未经过加工的代码，我们会把加工过后的结果放在 dist 当中 -> 浏览器当中运行的肯定是加工过后的结果。所以 baseDir 的值是 dist 

那这样的话，我们这个`browser-sync`最基础的操作就完成了。

![server](assets/img/2021-10-29-21-43-30.png)

我们把这个 `serve` 命令给它导出出去然后测试：

``` bash
yarn gulp serve
```

gulp 会自动启动 `serve` 这个任务。

在启动这个任务的时候，这个任务会自动的去唤醒浏览器，打开对应的链接。然后看到最终呈现的效果：

![效果](assets/img/2021-10-29-21-44-20.png)

只不过这个呈现的效果有点差强人意。

这原因很简单，我们回到代码当中，因为在我们的这个编译的过程当中，我们并没有去处理这个 `node_modules` 下面的这些模块的一个拷贝，我们只是把我们自己写的源代码做了一些编译以及一些文件的拷贝。

![文件处理](assets/img/2021-10-29-21-48-02.png)

所以，我们的`dist`目录下面是没有 `node_modules` 这些东西的。而 `node_modules` 它是我们项目根目录下的一些文件。

目前我们先不用着急，对于这个`bootstrap.css`文件的处理，我们之后会单独再去考虑。

我们现在要做的是在开发阶段能够让他们正常工作。

当然，我们有一个小办法，就是给这个`browser-sync`再单独加一个特殊的路由，让它对于这种`/node_modules`开头的这种网页请求，我们都给它指到同一个目录下面去。

这具体的指令方式我们就通过 `routes` 去指定。`routes`这个对象里面是会优先于我们 `baseDir` 的一个配置，也就是说一旦当我们的一个请求发生了过后，它会先去看在 `routes` 里面有没有对应的配位置，如果有话会先走`routes`里面的配置，否则的话，就会找 `baseDir` 下面对应的文件。

我们给`routes`这个对象要配置的键就是我们请求的那个前缀`/node_modules`

![指定 routes](assets/img/2021-10-29-21-58-22.png)

然后，我们要把它指到一个目录下面，那就是`'node_modules'` -> 这是一个相对路径，相对的是项目根目录下面的`node_modules`

这样一来，我们再去重新启动一下这个`serve`

``` bash
yarn gulp serve
```

此时我们针对于`bootstrap`这些库文件的请求，它就会自动映射到我们项目下面的`node_modules`

![效果](assets/img/2021-10-29-21-59-33.png)

至此，我们这个 web 服务器就可以正常工作了

不过，这样还不行，我们还可以再跟大家介绍一些其他的小选项。

对于这个 `bs` 的 `init` ，它还可以去指定一些其他的选项。比如说 `notify`

那这个 `notify` 的作用是什么呢？因为我们刚刚在启动`serve`的一瞬间，你会发现网页这个右上角会有一个提示 -> 提示我们 `browser-sync` 是否已经连接上。

这个连接小提示有可能会影响我们在页面当中去调试一些样式 -> 所以，我们可以把这个 「notify」 给它关掉，我们可以通过 `notify` 设置为 `false`

![notify](assets/img/2021-10-29-23-42-38.png)

这样一来，我们再去启动这个 web 服务器，以及后续我们去页面重新刷新的时候，它就不会再弹出这样一个提示了 -> 这个可以单独去了解一下。

除此之外，我们还可以去设置一下 `port` -> 也就是我们这个 `browser-sync` 的一个端口 -> 默认它启动端口是 `3000` -> 我们给它改成 `2080`，那这样话你再去启动的时候，它就会使用`2080` 这个端口

以上这两个是我们在使用 `browser-sync` 的时候比较常见的两个小选项，大家可以去了解一下。

然后，如果说还有一个选项的话，可能就要说到那个 `open` 了，因为我们 `browser-sync` 启动的时候，它会自动去帮你打开浏览器，而这个操作如果你觉得不是特别好的话，你可以把这个 `open` 设置为 `false`，那这样的话它就会取消这样一个小特性 -> 这个可以根据自己的情况去决定。 

现在有了这个`browser-sync`过后，接下来我们重点想考虑的肯定就是希望我们在修改完代码过后，可以去自动在浏览器当中看到最新的呈现效果。

现在我们去修改肯定是没有任何意义的，因为我们的修改，修改的是源代码儿，而源代码还需要经过编译，编译过后的结果才到 `dist` 目录下面 -> `dist` 下面再发生修改的话，`browser-sync`才有可能被监听到

所以我们这儿先不着急考虑源代码修改然后那个浏览器刷新，我们可以先考虑一下我们在 `dist` 下面的文件发生变化过后，我们怎么样让浏览器及时的更新过来。

在`serve`里边，我们可以给 `bs` 的 `init` 方法再去指定一个参数——`files`

![files](assets/img/2021-10-30-00-02-59.png)

这个参数它可以指定一个字符串 -> 这个字符串就是用来被 `browser-sync` 启动过后监听的一个路径通配符 -> 你想要哪些文件发生改变过后，这个 `browser-sync` 自动去更新浏览器，那你就可以在这通过通配符的方式去指定。

我们这儿指定的应该是 `dist` 下面的所有文件

保存一下，我们重新启动一下这个任务。

``` bash
yarn gulp serve
```

启动过后我们可以再回到 VS Code 当中。

注意，这个时候我们不是修改 `src` 下面的文件，因为 `src` 修改过后需要编译 -> 对于这个操作，我们还没有处理 -> 我们这里只是去修改这个 `dist` 下面的文件。

我们打开`dist`目录下的一个 HTML 文件（`index.html`） -> 对它做一个修改的测试 -> 比如我们找到这个页面上的一个标题部分，我们给它随便加上一些内容然后保存一下

![刷新页面](assets/img/2021-10-30-00-00-51.png)

此时你会发现页面上的内容已经更新过来了，这也就意味着我们此时 `dist` 下面的文件确实已经被监听了 -> 一旦当`index.html`这个文件发生变化过后，就可以同步到浏览器当中 -> 这对于样式来讲，这也是一样的。

![热更新](assets/img/2021-10-29-23-57-51.png)

> 似乎咩有刷新页面，页面状态还是存在的！ -> 修改样式不会刷新页面！

比如我们把这个`jumbotron`选择器的颜背景颜色改为`#ff0`，也就是黄色的颜色 -> 可以看到颜色也可以同步过去 -> 这样也就意味着 `browser-sync` 的这个同步没有任何问题。

那没有任何问题过后，下一步我们就要去考虑怎么样在修改 `src` 过后，`dist`目录就可以自动的去更新。

对于这个，其实我们要做的事情很简单，就是监视 `src` 下面文件的变化。一旦当它变化了过后，我们不是直接去刷新到浏览器，而是先去重新执行一下我们的构建任务 -> 这个我们再单独来看。

## ★Gulp 案例 - 监视变化以及构建优化

![构建优化](assets/img/2021-10-30-00-04-39.png)

有了这个开发服务器过后，接下来我们重点要考虑的就是如何在 `src` 下面的源代码修改过后自动的去编译。

这个过程我们需要借助于 gulp 提供的另外一个 API——`watch`

`watch` 这个 API ，它会自动监视一个文件路径的通配符，然后根据这些文件的变化决定是否要重新去执行某一个任务。

``` js
const { src, dest, parallel, series, watch } = require('gulp')
```

我们把这个 `watch` 解构出来过后，我们可以在 `serve` 命令开始的时候，我们去监视一些文件。

这个 `watch` 它的调用方式是指定两个参数：

第一个参数就是 `globs` ，也就是我们的通配符 -> 我们这要监视的实际上就是我们之前所有产生构建任务的这些路径。

这依次来看：

![watch](assets/img/2021-10-30-12-39-04.png)

首先第一个是 `sass` 文件的路径 -> `sass` 文件修改过后，我们要执行的是 `style` 这个任务 -> 任务的指定方式就是直接去指定这个任务函数就可以了 -> 这是第一个针对于样式文件的监视

我们再加上对于脚本文件、对于页面文件、对于图片、字体还有一些额外的文件 -> 每一个文件的路径我们都可以从原先的任务函数里边复制过来

第二个就是 `script` 这个任务

同理，其它的`src`下的任务以及`public`下的任务也是这样写

这几个文件修改过后，它就会执行相应的这些任务 -> 这些任务一旦触发了过后，就会把对应`dist`下面的文件给覆盖掉 -> 文件一旦覆盖掉过后，这个 `browser-sync` 它就会监视到 `dist` 里面的文件的变化，它会自动去同步到浏览器 -> 这样就可以实现我们一开始所设想的源代码修改过后自动编译到 `dist` 当中，然后再去同步到浏览器 -> 这个就是我们的一个设想

我们回来再来测试一下。

``` bash
yarn gulp serve
```

把 VS Code 放到屏幕的右侧，然后再把这个浏览器放到屏幕的左侧，这样的话会有一个对比，可以更明显一点。

此时我们尝试着去修改一下源代码。当然了，在修改源代码之前其实已经暴露出来一个小问题了。我们再去运行这个 `serve` 命令之前，其实应该先去执行一下 `build` -> 因为如果`serve`之前还没有先去执行一下那个 `build` 的话，那`dist` 可能还没有生成，那这样的话你启动`serve`可能会出问题。

以说我们在后面肯定也会把 `serve` 任务放到一个组合任务当中 -> 这个我们待会再来看。

我们现在重点来尝试一下这个源代码的修改有没有生效。

比如说我们修改一下这个 HTML 文件 -> 修改一下页头的标题，保存一下。

![HTML 更新](assets/img/2021-10-30-12-47-52.png)

![不要缓存](assets/img/2021-10-30-12-48-42.png)

这时候你会发现确实可以生效。因为我们这个 HTML 文件修改过后，它会自动同步到 `dist` ，然后再同步到浏览器当中。那这样的话，这个 HTML 的修改是没有任何问题的

我们再尝试着修改一下样式。样式的话我们通过在变量里面去修改这个背景颜色 -> `#fff` -> `#f00`（白色 -> 红色）

![修改样式](assets/img/2021-10-30-12-51-05.png)

> 不会刷新页面

可以看到，样式的修改也没有任何的问题 -> 这个也就意味着我们刚刚的那样一个设想已经可以正常工作了 -> 也就是文件修改过后自动编译，然后自动同步到浏览器。

这个`watch`操作基本上 OK 了，然后我们再回到代码当中。

关于`watch`这一块我们再跟大家介绍一个更常见的用法，因为现在对于像上面这些`sass` 文件，还有 `js` 文件，还有`html`文件，他们的这个编译实际上是有意义的 -> 但对于这个图片和字体，还有一些额外文件，它们的编译怎么说呢？不能说没有意义，只是在开发阶段实际上没有太大的意义。

为什么这样说？

因为图片包括字体，我们只是对它做了一个压缩 -> 压缩，我们之前已经介绍到了，它们是一个无损压缩，它并不影响最终在页面当中的一个呈现。

这也就意味着什么呢？意味着你在开发阶段去监视更多的文件去做更多的任务，你的开销也就会更大。而这个开销实际上对你开发阶段是没有意义的。**你只是在发布之前、上线之前希望通过压缩一下能够减小一下上线文件的体积 -> 从而提高你网站运行的一个效率**。

但是你如果现在开发阶段这么搞的话，它会降低你开发阶段的构建的效率。

所以说我们一般不会这么去做。

那具体的做法我们一般会这样去考虑 -> 怎么考虑呢？

我们在启动这个 web 服务器的时候，我们为`baseDir`去指定两个目录，一个是 `dist` 的目录，一个是 `src` 目录 -> 启动 `src` 目录的目的就是对于像图片也好、字体也好、还有像 `public` 这些，我们把它们就直接放在原位置，不让他们参与我们这次的构建，它只是在最终发布上线之前去做一下构建就可以了。

这具体怎么才操作呢？ -> 我们这一边操作，一边跟大家再来解释

我们先把这三个监视任务给他去掉：

![去掉监视任务](assets/img/2021-10-30-13-41-18.png)

然后我们给`baseDir`去指定为一个数组 -> 它支持一个数组 -> 它一旦指定为数组的话，它就是一个什么样的特点呢？ -> 当你一个请求过来过后，它会先到数组当中第一个目录去找，如果找不到这个文件的话，它就会依次往后去找

![找文件](assets/img/2021-10-30-13-47-32.png)

所以我们这儿再去指定一下 `src`，当然，你还需要去指令一下 `public` 目录。

为什么要这样搞来，我们一步步看就可以了。

这个时候你这样去想，当我们一个请求过来，如果说是 HTML 文件，那 HTML 文件我们肯定是需要编译的，因为你如果请求 `src` 下面的 HTML 它是有问题的，因为它里面是模板，对吧！ -> `dist` 下面才是最终生成的。所以说 HTML 没有问题。然后 `css` 和 `js` 也是一样的，它都必须要请求 `dist`下面。

但是一旦请求图片的话，其实你请求 `dist`下面的这个图片文件跟请求 `src` 下面的文件对于开发阶段来讲的话没有区别，因为他们只是压缩了一下，图片也没有质量上的一个变化。

所以我们这里就让它去请求到原文件。那这样的话，我们在开发阶段就减少了一次构建过程。

所以说我们这样把 `src` 放进来，那同理 `public` 也是相同道理，`public` 里面的文件只是拷贝过去，它没有任何的意义，所以说，这样的话，我们就可以提高一部分的构建效率。

我们回到我们的这个任务当中。

当然了，对于`image、font、extra`这一些文件发生变化过后，你肯定也需要同步到浏览器，但这个的话我们再单独说

现在我们去启动一下这个`serve`任务。

不过，我们在启动之前，我们先去`clean`一下，`clean`这个任务我们单独给它暴露出来一下 -> 把 `dist` 这个目录给它清空掉。（`dist`目录也会被清掉）

``` bash
yarn gulp clean
```

这个时候你再去启动 `serve` 就会遇到我们刚刚说的那个问题：

``` bash
yarn gulp serve
```

因为 `serve` 之前你必须要先去把 `src` 下面的这些`html、css、js`去给它们做一个编译操作。

所以我们`gulpfile`里边可以再单独地去加一个组合任务 -> 我们这个组合任务就叫做 `develop` -> 即开发的一个任务。

这个任务它必须要按顺序去执行 -> 这先去执行什么呢？ 

先去执行 `compile`，`compile`完了过后，我们就去执行一下这个 `serve` -> 因为一旦 `compile` 了过后，我们的这个样式文件、脚本文件、页面文件都已经转换过去了 -> 转换过去了过后，我们再去启动 `serve` 就不会有问题了。

但对于图片和字体这些，我们其实就应该从这个 `compile` 任务里面给它拿掉了，因为我们不需要在开发阶段去构建他们

![拿掉任务](assets/img/2021-10-30-14-09-28.png)

我们把这几个任务给拿出来 -> 放到哪呢？

放到这个 `build` 任务当中的`parallel`里边。

这个 `build` 任务我们可以理解成就是上线之前执行的任务。而 `compile` 任务它在上线之前也会用到，只不过它是一个子任务 -> 在开发阶段我们主要就用 `compile` 就可以了。因为这样的话，就会帮我们把那些在 `src` 下面没有办法直接在浏览器工作的文件做一个编译。

我们这个 `develop` ，它启动的时候先编译样式、脚本和页面，然后`dist`目录下有了编译完的文件过后，我们就启动 `serve`

启动 `serve`，我们看一下这个效果。

注意这个`develop`，我们要暴露出去 -> 把这`serve`去掉

![develop](assets/img/2021-10-30-14-20-36.png)

所以这实际启动的是`develop`

``` bash
yarn gulp develop
```

此时不要着急去看页面的效果，我们回到这个代码当中，我们来看 `dist` 下面的文件，那 `dist` 下面的 `html` 是有的，然后，样式文件也是有的，脚本文件也是有的，唯独就是图片跟字体文件是不存在的，但是这个并不影响我们在页面当中的呈现。

![无图片和字体](assets/img/2021-10-30-14-19-01.png)

例如我们在这个页面上的一些图标，还有我们的图片。

![图标、图片](assets/img/2021-10-30-14-17-41.png)

可以看到，这些图片、图标也都是可以正常工作的。

这原因都很简单，因为当图片这个请求过来，它请求找 `dist` 下面的文件 -> 找不到 -> 找不到的话就会找 `src` 下面的文件 -> 如果还找不到的话，就找 `public` 了。

例如像我们的`favicon.ico`它就会自动找 `public` 下面的

所以这样做并不影响我们在开发阶段的一个工作。

至此，我们这个 `develop` 任务，它其实就以一个最小的代价去把我们的这个应用给它跑起来了。

然后你在上线之前再去执行 `build`，就以最大模型的方式把所有的任务全部执行一下，因为每个任务对于上线之前都是有价值的，我们这里去做`develop`这样一个操作，只是对于它在开发阶段的构建过程做了一个优化。

以上，就是关于这个监视文件以及文件的这个变化过后然后更新浏览器 -> 主要的内容就是这些了。

当然，这还有一个需要补充的地方，那就是我们在 `src` 下的这些图片、字体，还有 `public` 下面的这些文件变化过后，我们也希望能够更新一下浏览器。

所以我们可以怎么搞呢？

![watch](assets/img/2021-10-30-14-38-24.png)

> `watch`监视多个路径下的文件 -> 它们都是为了执行`reload`这个任务，而像`js/css`都是单对单的，即一个处理对应一个不同的任务

我们可以通过一个 `watch`，注意，这个时候我们就不是去进行构建，**我们减少的是构建的次数** -> 这个过程我们可以指定一个数组 -> 这个数组就是把这三个路径全部给它监视下去。

由于这三种文件发生变化过后，我们要做的事情是一样的 -> 这三种文件发生变化过后，我们只需要去调用一下这个 `browser-sync` 模块提供的 `reload` 方法就可以了 -> 这个 `reload` 你也可以把它理解成一个任务 -> 因为在 gulp 当中，**一个任务就是一个函数**。所以我们给`watch`传一个函数进去是没有任何问题的

这样一来，这些文件发生变化过后，`bs.reload`会自动更新浏览器，那浏览器会重新发起对这个文件的请求，这样就可以拿到最新的这个文件了。

所以这种情况的话就是我们一个比较理想的状态。

对于文件，对于这个字体还有图片的变化，我们也可以尝试去演示一下

由于图片的变化，你可能还得去编辑图片，我们这儿因为图片当中有一个 SVG 文件，我们可以通过这个 SVG 的文件的变化来跟大家演示一下。

这个 SVG 是一个图标的 SVG，我们可以在 Features 这个里面可以看到：

![图片](assets/img/2021-10-30-14-32-52.png)

我们找到`src/assets/images`下的这些图标：

![svg](assets/img/2021-10-30-14-34-37.png)

我们随便去修改一个东西，只要你修改的话，它就会在页面上有一个更新 -> 你看到页面浏览器有一个刷新，就意味着这个`watch`工作是正常的 -> 这就可以了。

这是针对于我们这个文件修改过后的一个自动更新，以及我们如何去优化我们这个开发服务 -> 以最小模型的方式去启动这个开发服务就可以了。

当然，可能还有 -> 大家平时在看别人使用 gulp 的时候还会遇到一个情况，就是他们在使用的时候不使用这个 `files` 属性，他们使用的方式都是使用 `reload`  -> 这个其实也很简单，因为你每次文件发生变化过后，你在这个 `watch` 任务里面都能监视到。

那这样的话，我们是不是就可以？比如说如果后面可以传多个任务的话，那我是不是可以在`watch`再去传一个任务？

![reload](assets/img/2021-10-30-14-43-16.png)

这样一来，你这个`sass`文件发生变化 -> 先执行这个 `style`，执行完了过后，再执行一下`bs.reload`，那它就会自动去更新。但是，给`watch`的这个参数，`watch`不支持这样传啊！

所以，这可咋办呢？

![reload](assets/img/2021-10-30-14-58-34.png)

很简单，我们可以在`style`这个任务执行的后面，我们再去 `pipe` 一下 `bs.reload`， 而且这个 `reload` 它执行完的结果就是一个读写流（其实它不是读也不是写，它只是内部把这个文件流里面的信息给它推到了浏览器）

所以我们可以给`reload`指定一个参数`stream` -> 也就是以流的方式去往浏览器推 -> 这种方式其实会更常见一些。

同理，`script、page`任务我们都给它加上了这个 `reload` 操作

这个时候你这个 `files` 就不需要了：

![files](assets/img/2021-10-30-14-59-17.png)

我们再重新来看

``` bash
yarn gulp develop
```

这依然是 OK 的。

刚刚说的这里几种方式，除了那个优化是必要的，其他的就是防止大家平时在看到一些其他项目当中的 `gulpfile` 的时候会有一些疑惑，所以我们单独来说一下。 

这个时候我们再去尝试着修改一下样式文件，去看一下这个过程有没有问题。

测试得知也没有任何问题。

以上就是关于这个文件修改过后，然后自动去编译，然后再自动去更新的整个一个过程。

这里我们简单总结一下。

首先第一个 -> 我们用到`browser-sync`它提供的一个 web 服务器去启动我们的 web 服务，这样的话，这有利于我们在开发阶段所见即所得。这是第一个。

第二个 -> 我们介绍了一个 API 叫做 `watch`，这个 `watch` 任务它可以去监视一个文件路径的一个通配符，根据这个文件监视到的结果去决定是否要去执行一个任务 -> 这是 gulp 提供的 `watch`

第三个 -> 就是我们在这个`serve`过程当中可以重新思考一下哪些任务是在开发阶段需要去执行的，哪些任务不是必须要执行。

例如我们这儿举两个例子：

一个是 `style` ，`style` 它必须要执行，否则的话，`sass` 文件没有办法在浏览器直接工作，所以它必须要执行。

然后像 `image` 这个任务，它其实可用可不用。

为什么呢？

因为图片只是做了一个压缩，而且是图片画质无损的压缩，所以说它可以不做 -> 不做的话，我们在开发阶段就可以减少一次构建次数，它的效率就会提高。

其他的`font`、`public`下的文件都是同理。

这个就是我们刚刚整个一个过程给大家介绍的主要内容。

> 记笔记的时候，记住转折点，也就是下一个操作的标题，或者说是引子，或者说是「为什么」

## ★Gulp 案例 - useref 文件引用处理

![useref](assets/img/2021-10-30-15-01-03.png)

截止到目前，我们绝大多数构建任务基本上已经都完成了 -> 这一些任务它基本上完成了我们核心想要做的一些事情。

但是对于 `dist` 下生成的这些文件还有一些小问题。

我们重新去运行一下`build`

``` bash
yarn gulp build
```

重新运行完这个 `build` 过后，我们 `dist` 下面会按照最终上线的状态去呈现我们的所有生成的文件。

这些文件我们可以打开看一下。

![部署上线](assets/img/2021-10-30-19-27-25.png)

针对于像这个 HTML 文件里面，它会有一些像这种在`node_modules`当中的一些文件的依赖 -> 这些文件并没有拷贝到我们的 `dist` 目录

所以，我们将这个 `dist` 目录部署上线的话，这肯定会出现问题 -> 它会找不到有关像`bootstrap`这样的一些文件。

![文件](assets/img/2021-10-30-19-29-54.png)

当然，我们在开发阶段去运行是没有问题的，其原因是因为我们在 `serve` 那个命令里面去做了一个路由的映射 -> 这个并不能在线上的环境去这样去做。

所以说我们针对于`/node_modules`的请求的这个问题还需要单独去处理。

针对于这种问题，其实处理的方式有很多

有一种，比如说我们在这个 HTML 代码里面就写入一个我不存在的路径，然后我们通过构建的方式把这些文件给它拷贝到我们指定的那个路径 -> 这种做法也行

但是这相对来说就比较 low 一点了。

我们这里跟大家介绍一个更为常见或者说更为强大的一种方式，就是借助一个叫做 `useref` 的插件。

这个 `useref` 插件，它会自动的去处理我们 HTML 当中的这些构建注释。

什么叫「构建注释」？

像我们这里面的这一个注释，它其实有一定的规律，大家可以仔细看一下。

![构建注释](assets/img/2021-10-30-19-43-03.png)

首先它会有一个开始的 `build` 然后有个  `endbuild`

在开始和结束之间都是对资源的一些引入，它主要引入的就是 CSS 和 JS -> 引入完了过后，它会在后面去标记我这引入的是 CSS 还是 JS -> 最后就会再去指定一个路径 -> 那这是什么意思呢？

这个意思是说我们会自动地将开始标签和结束标签中间引入的这些文件最终打包到一个文件当中 -> 那这个文件的路径就是 `assets` 下面的 `styles` 下面的 `vendor .css` 

如果说你引入了多个 CSS 文件的话，那它可以把这些文件都合并到一块。

这就是这个插件，它用起来非常强大。

除此之外，我们还可以在这个过程当中自动的对这些文件做压缩。这相对来讲的话会比我们使用其它的方式要更为完善一点。

因为在这个过程当中，我们能把剩下的什么压缩、合并等所有的事情统统都给它完成。

所以我们去使用一下这个叫做 `useref` 的插件。

在使用之前，我先把这一段给它复制下来：

![复制](assets/img/2021-10-30-19-40-57.png)

待会我们会有一个对比

我们回到 `gulpfile` 当中。在这 `gulpfile` 当中，我们肯定要去添加一个新的任务，只不过这个任务我们需要用的一个插件 -> 我们先去安装一下

``` bash
yarn add gulp-useref --dev
```

`useref`的意思就是使用的依赖或者说引用关系 -> 你可以把它理解成引用关系

然后我们通过使用它，你再去慢慢体会它的一个作用。

回到`gulpfile`里边，定义一个`useref`任务

在这个任务当中，它跟我们普通的任务也是一样的，我们可以去`return`一个`src`然后去找一些文件去做一些构建的操作。

这个时候我们要找的文件并不是 `src` 下的 HTML -> 我们要找的是 `dist` 下的 HTML

因为在 `src` 下面的 HTML 它是模板，模板里面你做这个 `useref` 操作是没有意义的。只有当 HTML 这些原文件都被转换生成过后，我们再去做，这才有意义。

所以这个也是为什么我们最后再来说的一个原因。

`src('dist/*.html', { base: 'dist' })` -> 我们把它同样也是指定一个 `base` 目录。当然，这个`base` 可用可不用。因为这跟我们之前一样，它所在的目录就是 `dist` 目录，所以这指定不指定是没有什么区别的 -> 主要是为了统一，我们就都指定了。

然后我们再把这个创建的读取流`pipe` 到 `useref` 插件 -> 这个插件它会被自动加载进来，我们通过 `plugins.useref` 去创建一下一个转换流 -> 这个转换流它会自动的去把我们刚刚在代码当中的那种构建注释，就是我们所谓的这种构建注释：

![复制](assets/img/2021-10-30-19-40-57.png)

去做一个对应的转换

这个转换它需要指定一个参数叫做 `searchPath` -> 从字面意思应该都能猜到，因为你去做这个`bootstrap.css`文件的合并，那你肯定得先去找到这些文件 -> 找这个文件就涉及到我们需要去哪个目录下找。

例如我们要去找这个`main.css`文件，那么肯定是在 `dist` 这个目录里边找。

对于 `/node_modules` 这种我们肯定是在项目的根目录下去找。

所以我们需要去指定两个：

- 第一个是 `dist` 
- 第二个是`.` -> 针对于像这种数组型的这种参数的话，我们一般都是把使用的更多的情况放在前面，相对少一点的放在后面

![数组值](assets/img/2021-10-30-19-58-21.png)

有了这个`useref`过后，我们紧接着把它 `pipe` 到一个目标路径。

这个 `pipe` 到 `dest` 生成的一个读取的写入流当中 -> 我们同样把它指定到 `dist` 目录，当然这个里面肯定会存在一定的不合理，待会我们再来解决，我们先来看效果。

![写入流](assets/img/2021-10-30-20-14-30.png)

现在有了这个`useref`任务过后，我们把这个任务同样暴露出去，我们可以在外界去测试一下这个任务

回到命令行当中：

``` bash
yarn gulp useref
```

此时这个任务正常执行。

执行过后，我们 `dist` 下面的这些文件就会发生变化，你需要注意的是，它会自动的把 `dist` 下面的 HTML 拿出来去做 `useref` 的操作，操作完了过后又返回（输出）到`dist`

所以说我们直接去看 `dist` 下面的文件。

![index](assets/img/2021-10-30-20-16-28.png)

此时这个 HTML 文件就已经不再跟我们之前看到那个 HTML 一样了，它会把那些构建注释全部去掉。然后把构建注释里面包含的那些内容最终合并到一个文件当中。

当然，我们原先对`index.html`这个`useref`操作之前，它的这个 `bootstrap.css` 只是一个文件，所以你感觉不到把这些`css`文件都合并到一个`vendor.css`文件当中去

我们可以看下面这一块儿，它之前引入了很多第三方的脚本文件

![js](assets/img/2021-10-30-20-19-32.png)

这最终都是合并到一个`js`文件当中，而且这会给你生成对应的这些文件。

例如我们在`dist/assets/styles`下，可以看到这个 `vendor.css` -> 这个文件里面的内容实际上就是从 `bootstrap.css` 里边合并过来的文件。

![css](assets/img/2021-10-30-20-20-22.png)

我们再来看一下 `dist/assets/scripts`下的`vendor.js` -> 这里边有 jQuery 的库，Boostrap 的库，还有其它的一些库 -> 所有的库都会被合并到一个文件当中。

![js](assets/img/2021-10-30-20-21-32.png)

以上这个就是我们所谓的这个`useref`插件的一个作用。

再对比一下之前的

之前的状态是这样一个状态：

![之前的状态](assets/img/2021-10-30-20-23-50.png)

然后经过 `useref` 过后，它会自动的去把 `useref` 里面遇到的这些构建注释当中引入的这些资源全部合并到同一个文件当中

那这个就是 `useref` 的作用。

当然了，这还不行，光去这样使用还不行，因为这个 `useref` 它在这个过程当中自动的去修改了你的 HTML，并且帮你把 HTML 里面依赖的那些文件去创建了一些新的文件生成到`dist`当中。

这个过程它会在这个读取流当中去创建一些新的文件 -> 我们可以对这些新的文件，做一些操作

做一些什么操作呢？

![操作](assets/img/2021-10-30-20-25-33.png)

例如我们创建的 JS 文件，我们希望能对它做一些压缩，创建的 CSS 我们也希望能对它做一些压缩。

所以我们应该怎么去做呢？我们可以单独去再加一些插件 -> 这个操作我们再单独来看
