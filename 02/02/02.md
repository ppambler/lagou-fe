### ✍️ Tangxt ⏳ 2021-11-08 🏷️ ES Modules

# 02-ES Modules 特性、ES Modules 导出

## ★ES Modules 特性

![ES Modules](assets/img/2021-11-08-18-51-19.png)

对于 ES Modules 的学习，我个人觉得可以从两个维度去入手。

首先我们必须要去了解它作为一个规范或者说标准，它到底**约定了哪些特性和语法**。

其次就是我们如何通过一些工具或者方案去解决它在运行环境当中**兼容性**所带来的问题。

那么接下来我们就一起先来梳理一下 ES Modules 当中的一些语法特性。

1）基本使用

我们回到 VS Code 当中去尝试使用一下这些特性。

正如之前所说的，目前市面上绝大多数的浏览器已经支持 ES Modules 了，所以，我们只需要通过给页面当中的 `script` 标签去添加一个 `type` 为 `module` 的一个属性，然后，这样一来，我们就可以直接去使用 ES Modules 的标准去执行这个当中的一些 JavaScript 代码了，那我们这里先来尝试一下。

![简单测试](assets/img/2021-11-08-23-36-19.png)

我们添加一个 `script` 标签，我们把它的 `type` 设置为`module`。那这样的话，这个标签的内部就算是一个模块了，我们在这个模块当中先通过 `console.log()` 去输出一个简单的内容，然后我们打开命令行终端。

在这里我使用一个叫做 `serve` 的一个 npm 的工具去启动一个 HTTP Server -> 启动过后我们就可以通过这个地址去打开我们刚刚的这个页面。

![serve](assets/img/2021-11-08-23-36-56.png)

打开页面过后，我们去启动一下 Chrome 的调试工具，我们打开一个`Console` 这个面板。那这个时候我们就能看到我们刚刚这个脚本的正常执行了。这也就意味着`script`标签通过 `type` 设置为`module`过后，它仍然可以正常作为 JS 去执行。

只不过这相对于普通的 `script` 标签来说，它会有一些新的特性。

我们分别来看一下。

2）自带严格模式

![严格模式](assets/img/2021-11-08-23-43-01.png)

> 没有`type="module"`的`script`标签也是 HTML 标签

首先第一个特性就是我们在 ES Modules 当中，它会自动去采用严格模式，忽略你去使用 `use strict;` 这种文件头的方式去声明严格模式。说白了，你不加 `use strict;`，它也是严格模式。

严格模式当中有一个代表 -> 那就是我们不能在全局范围直接去使用 `this`，因为在非严格模式下面， `this` 它实际上指向的是全局对象。我们把 `type="module"` 删除掉回到浏览器当中，这时候你可以看到 `this` 打印出来的实际上就是 `window` 对象，但是我们通过添加 `type="module"` 的话，你就会发现它是一个 `undefined` -> 这是它的第一个特性。

3）单独的私有作用域

![私有作用域](assets/img/2021-11-08-23-49-10.png)

第二个特性就是每一个 ES Modules 它都是运行在单独的私有作用域当中。

这具体来看就是我们再单独去添加一个 `script` 标签，我们把`type`同样设置为`module`。

在这个 `script` 当中，我们去添加一个用 `var` 声明的 `foo` 变量，我们添加完了过后紧接着把它打印出来。

然后我们再去添加一个新的 `script` 标签。有了这个 `script` 标签过后，我们在这个里面同样再去打印一下 `foo`，然后我们回到浏览器当中。

这时候你会发现我们在第一个`script`标签当中可以正常打印出来这个 `100`。但是在第二个标签当中，它去打印这个 `foo` 就报错了，报错信息说的是 `foo is not defined` -> 这也就意味着我们每一个 ES Modules 它都是有一个独立的私有作用域，那我们也就不用再担心我们直接在全局范围去使用那些变量，会造成全局作用域污染的问题。

4）CORS 的请求姿势

![CORS](assets/img/2021-11-09-00-04-13.png)

> 自带 Ajax、Fetch 特性

第三个特性就是在 ES Modules 当中，我们的外部 JS 文件是通过 CORS 的方式去请求的，那也就意味着我们的 JS 模块如果说不在同源地址下面的话，然后我们需求去请求这个服务端地址，那它在响应的响应头当中必须要提供有效的 CORS 标头 -> 这里我们通过百度 CDN 的地址做一个尝试 -> 这个地址是不支持 CORS 的。我们去请求的时候会发现它会报一个跨域的错误。而且在 Network 面板当中我们也会发现这样一个请求实际上是被浏览器终止掉了。

所以说如果你要去请求一个外部地址的话，那就需要注意服务端必须要支持 CORS -> 这里我们再换做一个支持 CORS 的一个服务端地址。那这个时候你会发现这一次对于 jQuery 这个文件的请求它是一个正常的请求。

另外，CORS 不支持文件的形式去访问，所以说我们必须要使用 HTTP Server 的形式去让这个页面工作起来 -> 这个问题实际上在我们实际开发的时候不会遇到，原因很简单，因为我们在实际开发的最终运行环境肯定都是 HTTP 的 Server

💡：关于跨域？

![跨域](assets/img/2021-11-09-00-10-13.png)

➹：[跨域资源共享 CORS 详解 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2016/04/cors.html)

5）自带 `defer`

我们再来看第四个小特性，第四个特性是 ES Modules 当中的 `script` 标签，它会自动的去延迟执行脚本。

这一点等同于我们`script`标签的 `defer` 属性。那也就是说我们通过添加`type="module"`就相当于去添加了一个 `defer` 属性 -> 我们应该也知道，网页的加载过程默认对`script`标签它是采用立即执行的这样一个机制，那页面的渲染会等待这个脚本的执行完成，才会继续去往下渲染。

在这里我们尝试添加一个脚本文件（`demo.js`）来去试验一下

``` js
// demo.js
alert('hello')
```

我们在这个文件当中通过 `alert` 去模拟一下这个脚本当中的一个阻塞的操作。然后我们回到页面（HTML）当中，在这个脚本的下面再去添加一些需要显示的内容，有了这些过后我们就可以回到浏览器。

![页面](assets/img/2021-11-09-00-50-23.png)

此时在浏览器当中去刷新这个页面，你会发现弹出对话框的时间，而我们那个网页当中需要显示的内容并没有呈现出来，因为这个时候正在去执行我们的脚本。

![页面显示](assets/img/2021-11-09-00-49-44.png)

脚本执行完成，也就是我们点击完成过后才会去显示我们想要显示的内容。

那这个时候如果说我们去添加了一个`type="module"`的话，那就相当于让这个脚本启用一个延迟执行的这样一个机制 -> 延迟执行它会等待网页的执行，也就是网页的渲染完成了过后再去执行我们的脚本，那这个时候就不会阻碍我们页面当中元素的显示 -> 这一点就跟我们使用 `defer` 属性是一样的。

![ESM](assets/img/2021-11-09-00-53-14.png)

> `<script defer src="demo.js"></script>`

所以这个小特点实际上也是 ES Modules 当中对 `script` 标签做的一个小小的改进。

💡：`defer` vs `async`？

![defer vs async](assets/img/2021-11-09-00-17-56.png)

不管是`async`还是`defer`，这俩兄弟都只适用于外部 JS 文件

![async defer](assets/img/2021-11-09-00-40-27.png)

> 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 `DOMContentLoaded` 事件触发前执行，因此最好只包含一个延迟脚本 -> JavaScript 高级程序设计（第 3 版），人民邮电出版社，Kindle 位置 （639-641) 

➹：[一图看懂 script 标签中 defer 和 async 的区别_小小前端-CSDN 博客](https://blog.csdn.net/weixin_43967603/article/details/106309099)

➹：[defer 和 async 的区别 - SegmentFault 思否](https://segmentfault.com/q/1010000000640869)

➹：[async vs defer attributes -  Growing with the Web](https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html)

➹：[脚本：async，defer](https://zh.javascript.info/script-async-defer)

💡：页面生命周期：`DOMContentLoaded`、`load`？

- `DOMContentLoaded` —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和样式表之类的外部资源可能尚未加载完成。
- `load` —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等

➹：[页面生命周期：DOMContentLoaded，load，beforeunload，unload](https://zh.javascript.info/onload-ondomcontentloaded)

6）小结

总的回顾一下，我们在 ES Modules 当中有这么四个小特点，这四个特点分别是：

- 我们在 ES Modules 当中会自动去启用严格模式
- 另外，每一个 ES 模块它都会有一个独立的作用域 -> 这一点实际上是非常重要的
- 然后第三个就是 ES Modules 对于外部文件的请求，它是通过 CORS 这种跨域请求的方式去请求的 -> 这个时候你需要去注意你请求的那个地址必须要支持 CORS
- 然后最后一个就是 ES Modules 当中对于 `script` 标签默认启用了延迟执行脚本的这样一个机制 -> 这个也是一个需要注意的一个小点。因为这会导致有的时候我们去看 `console.log()`，你会发现不同的模块它的执行顺序并不跟你的引入顺序是一样的，那这个是需要注意的！

![四个小特点](assets/img/2021-11-08-22-52-47.png)

## ★ES Modules 导出

![ES Modules 导出](assets/img/2021-11-09-00-58-44.png)