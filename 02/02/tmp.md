早期的前端技术标准根本没有预料到前端行业会有今天这样一个规模。所以说很多设计上的遗留问题就导致了我们现在去实现前端模块化的时候会遇到很多的问题。那虽然说现如今这一些问题都被一些标准或者工具去解决了，但是它的一个解决的演进过程我个人认为是值得我们去思考的。所以说接下来我们就一起先来了解一下我们在前端方向去落实模块化的一个演变过程。
那在最早期我们 javascrib 的当中的模块化实际上就是基于文件划分的方式去实现的，那这也就是我们 web 当中最原始的模块系统。那具体的做法就是将每一个功能以及它相关的一些状态数据，我们单独存放到不同的文件当中，我们去约定每一个文件就是一个独立的模块。我们去使用这个模块的话，就是将这个模块引入到页面当中，然后一个 script 标签就对应一个模块，然后我们再去在代码当中直接调用模块当中的全局成员。那这个成员有可能是一个变量，也有可能是一个函数。当然这种方式的缺点也十分明显。那我们所有的模块都直接在全局范围去工作，它并没有一个独立的 file 空间。那这样就导致我们模块当中所有的成员都可以在模块外部被任意的去访问或者修改，而且模块一旦多了过后很容易产生命名上的冲突。那除此之外，我们也没有办法很好的去管理模块与模块之间的一个依赖关系。反正总的来说的话，这种方式完全依靠约定项目，一旦上了体量过后就彻底不行了。但是在这个过程当中暴露的一些问题，如果我们都能很好去解决的话，那我们就可以更好地去实现模块化了，所以说我们就有了第二阶段。
那在第二阶段当中，我们约定每一个模块只暴露一个全局的对象，我们所有的模块成员都挂载到这个对象下面。那具体的做法就是在第一个阶段的基础之上，我们通过将每个模块包裹成为一个全局对象的方式去实现。那有点儿类似于我们在模块儿内去为我们模块儿内的一些成员去添加了命名空间的这样一种感觉。所以说我把这种方式称之为命名空间的方式。那通过命名空间的方式，我们就可以减小命名冲突的可能。但是这种方式仍然没有私有空间。所以说我们的模块成员仍然可以在外部被访问或者被修改，我们的这个模块之间的依赖关系也没有得到解决。
那我们再来看第三阶段。在第三阶段当中，我们使用立即执行函数的这种方式去为我们的模块儿提供私有空间。那具体的做法就是将我们模块儿中每一个成员都放在一个函数提供的 seal 作用域当中。对于需要暴露给外部的成员，我们可以通过挂载到全局对象上的这种方式去实现。那这种方式它实现了私有成员的概念，也就是我们的私有成员只能在模块内部的这些成员通过闭标的方式去访问，而在外部我们是没有办法去使用的。那这样的话就确保了我们私有变量的安全。而且我们还可以利用这个自执行函数的参数去作为我们依赖声明去使用。这样的话就使得我们每一个模块他们之间的一个依赖关系就变得更加明显了。例如我们在这个模块当中我们要去使用几 query 那我们就可以通过我们这个立即调用的函数去接受一个 quirt 的参数，我们在立即调用时我们去传递 query 这个参数。
这样的话我们在后期去维护这个模块的时候，我们就可以很清楚的知道这个模块它需要依赖及 query 那以上这几个阶段就是我们早期开发者，在没有任何工具和规范的这种情况下，我们对模块儿化的一种落地的方式。那这些方式确实解决了我们在前端领域去实现模块儿化的各种各样的问题，但是它仍然存在一些没有解决的问题。那针对于这些问题，我们需要单独再来看。
