### ✍️ Tangxt ⏳ 2021-08-16 🏷️ Vue

# 06-8-身份认证-处理 Token 过期

## ★概念介绍

问题：关于 Token 过期

用户登录成功过后，我们收到了这么一个对象：

![user](assets/img/2021-09-03-13-44-57.png)

这个数据对象里边有一个`access_token`属性，我们透过这个属性去请求需要授权的接口，这样才能拿到对应的数据 -> 它表示用户的身份

然而，这个`token`它是有过期时间的，注意，这个过期时间是后端设置的，而前端是设置不了的

在这里后端默认设置的过期时间是`24`个小时，也就是说，一天以后你这个`token`就过期了，而这意味着`token`无效了，你也就无法利用这个`token`来获取数据了

如果你非得用这已经过期的`token`去请求，那么就会得到一个`401`的响应（无乱是`token`过期，还是验证失败都会返回`401`）

测试`token`过期 -> 无须等`24`小时，直接修改本地存储的`token`就好了

![修改 token](assets/img/2021-09-03-13-52-38.png)

效果：

![token 无效](assets/img/2021-09-03-13-55-00.png)

无效的`token`或过期的`token`都会受到`401`响应

![状态码](assets/img/2021-09-03-13-56-59.png)

所以在这种情况下，我们该咋办呢？

最简单的处理方式就是 -> 遇到`401`让用户重新登录一下呗！

这样做是可以的，当然，我们是设置了`24`小时的过期时间 -> 但是，有些网站，它是`3`分钟、`5`分钟、`10`分钟这样`token`就过期了，过期了就叫用户登录，这样会**让用户频繁登录**的，而这显然用户体验很不好！

💡：能不能在`token`过期后，用户不用重新登录，也能解决`token`过期的问题呢？

💡：`access_token`、`expires_in`、`refresh_token`的作用？

1. 获取需要授权的接口数据
2. 设置`access_token`的过期时间
3. 刷新获取新的`access_token`

💡：为什么`access_token`要有过期时间以及为啥要把它设置的比较短？

为了安全 -> 它代表着用户的身份，一旦这个身份标识遭到了泄漏，那不怀好意的人就可以拿这个`access_token`来冒充用户的身份来进行一些操作了

设置过期时间以及设置得比较短，可以降低风险

💡：用户在访问网站期间，`access_token`过期了？

利用`refresh_token`来刷新获取一个新的`access_token`，而旧的过期的`token`也就没啥用了

获取了新的`token`，就可以进行后续的操作了

💡：获取新`access_token`的处理流程？

有两种姿势：

1. 在请求发起前拦截每个请求，判断`token`的有效时间是否已经过期了，若已过期，则将请求挂起，先刷新`token`后再继续请求
   1. 做法：`axios`拦截器、`express_in`、`refresh_token`
2. 不在请求前拦截，而是拦截返回后的数据。先发起请求，接口返回过期后，先刷新`token`，再进行一次重试
   1. 做法：过期的话，后端会返回`401`，判断这个码，然后再`refresh_token`

选择哪种方式呢？

姿势一：

- 优点：在请求前拦截，能节省请求、省流量
- 缺点：需要后端额外提供一个`token`过期时间的字段，使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截就会失败

姿势二：

- 优点：不需额外的`token`过期字段，不需判断时间
- 缺点：会消耗多一次请求，耗流量

不管过期与否，先试一下呗！不行，那就`refresh`一下再搞呗！

---

所以选择哪种？

我们从中可以看到，姿势一、二的优缺点都是互补的，姿势以有校验失败的风险（本地时间被篡改时，当然，一般没有用户闲的蛋疼的去改本地时间），姿势二更简单粗暴，等知道服务器已经过期了再重试一次，只是会耗多一个请求，其实这个流量可以忽略不计

**选择姿势二来处理刷新`token`的操作** -> 推荐这种做法，因为它是绝对没有问题的，当然，你也可以私下尝试一下姿势一的做法！

---

以上就是关于`token`过期的一个基本逻辑了！

## ★分析响应拦截器


