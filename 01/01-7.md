### ✍️ Tangxt ⏳ 2021-05-10 🏷️ es6

# 01-7-Proxy、Proxy vs defineProperty、Reflect

![Kitten sees a tiger in its reflection](assets/img/2021-05-12-11-28-30.png)

> Kitten sees a tiger in its reflection

## ★Proxy

> 代理对象

1）概述

如果我们想要监视某个对象中的属性读写，那么我们可以使用 ES5 所提供的`Object.defineProperty`这样的方法来去为我们的对象添加属性，这样一来就可以捕获到我们对象当中属性的读写过程

这种方法其实应用得非常广泛，在 Vue3.0 以前的版本就是使用这样一个方法来去实现**数据响应**的，从而完成双向数据绑定

而在 ES2015 当中，全新设计了一个叫做「Proxy」的类型！ -> 它就是专门用来为对象设置访问代理器

如果你不理解什么叫做「代理」，那么你可以把它想象成「门卫」即可！也就是说，不管你进去拿东西，还是往里边放东西，都必须要经过这样一个代理 -> 通过「Proxy」，就可以轻松监视到对象的读写过程！

或者这样理解代理：

![Proxy](assets/img/2021-05-12-11-34-53.png)

再或者这样：

![代理服务器和代理对象](assets/img/2021-05-19-17-07-10.png)

相比于`Object.defineProperty`，**`Proxy`的功能要更为强大，使用起来也更为方便**

next：如何去使用 Proxy？

2）使用

定义一个 `person` 对象：

``` js
const person = {
  name: 'zce',
  age: 20
}
```

通过`new Proxy`的方式来去为`person`创建一个代理对象：

``` js
const personProxy = new Proxy()
```

`Proxy`这个构造函数：

- 第一个参数就是我们需要代理的目标对象 -> `target`
- 第二个参数也是一个对象 -> 可以把它称之为代理的处理对象 -> `handler`（定义哪些操作将被拦截，以及重新定义对对象默认行为的操作）
  - 可以通过 `get` 方法监视我们对目标对象属性的访问
    - 最简单的使用姿势，就是只接收两个参数：`target`（所代理的目标对象）、`property`（外部所访问的这个属性的属性名）
    - 该方法的返回值：该值将会作为外部去访问我们这个属性所得到的结果
  - 通过`set`方法来监视我们对象当中设置属性这么一个过程

1、测试 `get` 方法

![get](assets/img/2021-05-19-11-03-17.png)

`get`方法监听到了属性的读取，也知道是哪个属性在搞事情！除此之外，我们得到的结果也确实是 `get` 的返回值！

这个方法内部的正常逻辑，它应该是这样的：

> 判断代理目标对象当中是否存在 `prop` 这个属性，如果存在就返回对应的值，反之，则返回 `undefined`，或者是一个默认值 `'default'`

``` js
const person = {
  name: 'zce',
  age: 20
}

const personProxy = new Proxy(person,{
  get(target,prop,receiver) {
    return prop in target ? target[prop] : 'default'
    // console.log(target,prop,receiver)
    // return 666
  }
})

console.log(personProxy.name) // 'zce'
```

此时，你可以看到，这个`name`属性被正常输出了！

如果你访问的是一个不存在的属性，如 `personProxy.xxx`，那么其所输出的结果就是默认值`'default'`了！

2、测试 `set` 方法

这个方法默认接收三个参数：

- target：代理目标对象
- prop：我们要写入的属性名称
- value：我们要写入的属性值

通过代理对象，为 `person` 写入一个 `gender` 属性：

![set](assets/img/2021-05-19-16-35-12.png)

`set`方法内部正常的逻辑：

> 为代理目标设置指定的属性，在此之前，我们可以对数据进行校验！

``` js
const personProxy = new Proxy(person, {
  // 监视属性读取
  get (target, property) {
    return property in target ? target[property] : 'default'
    // console.log(target, property)
    // return 100
  },
  // 监视属性设置或创建
  set (target, property, value) {
    if (property === 'age') {
      if (!Number.isInteger(value)) {
        throw new TypeError(`${value} is not an int`)
      }
    }

    target[property] = value
    // console.log(target, property, value)
  }
})

personProxy.age = 100
```

如果你这样设置一个不正常的值：

``` js
personProxy.age = '666'
```

那么就会抛出错误：

![error](assets/img/2021-05-19-16-41-46.png)

💡：使用 `set` 方法一般需要返回一个 `true`，用于指示这个操作成功了？

> 使用 `Proxy`，你可以很容易地验证传递给对象的值。

``` js
let validator = {
  set: function(obj, prop, value) {
    if (prop === 'age') {
      if (!Number.isInteger(value)) {
        throw new TypeError('The age is not an integer');
      }
      if (value > 200) {
        throw new RangeError('The age seems invalid');
      }
    }

    // The default behavior to store the value
    obj[prop] = value;

    // Indicate success
    return true;
  }
};

const person = new Proxy({}, validator);

person.age = 100;
console.log(person.age); // 100
person.age = 'young';    // Throws an exception
person.age = 300;        // Throws an exception
```

---

以上就是 `Proxy` 的一些基本用法，之后`Proxy`会用得越来越多，如 Vue3.0 就使用 `Proxy` 去实现内部的数据响应了

## ★Proxy 对比 defineProperty

了解了 Proxy 的基本用法过后，接下来就深入探索一下相比于`Object.defineProperty`，Proxy 到底有哪些优势！

首先，最明显的优势在于 Proxy 要更为强大一些，而这个「强大」具体体现在`Object.defineProperty`它**只能够监视到对象属性的读取或者是写入 -> 读写**

而 Proxy 它可以监视到很多`Object.defineProperty` 监视不到的行为 -> 换句话说「**Proxy 能够监视到更多对象操作**」，如`delete`操作、对对象当中方法的调用等等……

1）优势 1：Proxy 可以监视读写以外的操作

``` js
// 优势 1：Proxy 可以监视读写以外的操作 
// --------------------------

const person = {
  name: 'zce',
  age: 20
}

// 为 person 对象定义一个 Proxy 对象
// 在 Proxy 对象的处理对象当中额外添加了一个 deleteProperty 方法
// 该方法会在外部对当前这个 person 对象进行 delete 操作时自动执行！
// 该方法同样接收两个参数 -> 代理目标对象 + 你要删除的这个属性的名称
const personProxy = new Proxy(person, {
  deleteProperty (target, property) {
    // 输出一个消息
    console.log('delete', property)
    // 使用 delete 操作，删除掉目标信息
    delete target[property]
  }
})

// 外部操作：直接通过 delete 去删除这个代理对象当中的 age 属性
delete personProxy.age
console.log(person)

// delete age
// { name: 'zce' }
```

可以看到，Proxy 它确实能够做到 `Object.defineProperty` 不能做到的事情！

当然，除了 `delete` 这个操作以外，还有很多其它的对象操作都能够被监视到，如：

![其它 handler](assets/img/2021-05-19-19-10-07.png)

> 这个表格里边的内容有很完善的介绍，你可以单独去做一些测试！

2）优势 2：Proxy 更好的支持数组对象的监视 

以往，我们想要通过`Object.defineProperty`去监视数组的操作 -> 最常见的一种方式就是通过**重写数组的操作方法** -> 这也是 vue 里边所使用的方式

大体的思路是这样的：

> 通过自定义的方法去覆盖掉数组原型对象上的`push`、`shift`之类的一些方法，以此来去劫持对这个方法调用的过程 -> 具体的实现，vuejs 源码剖析课程里边有专门介绍到

回过头来，话说，如何使用 Proxy 对象去对数组进行监视呢？

1. 定义一个 `list` 数组
2. 为这个 `list` 数组定义一个 Proxy 对象 `listProxy`
3. 在这个 Proxy 对象的处理对象上
   1. 添加一个`set`方法 -> 监视数据的写入
4. 测试 -> `listProxy.push(666)`

``` js
// 优势 2：Proxy 可以很方便的监视数组操作 
// --------------------------

const list = []

const listProxy = new Proxy(list, {
  set (target, property, value) {
    console.log('set', property, value)
    target[property] = value
    return true // 表示设置成功
  }
})

listProxy.push(100)
// set 0 100
// set length 1

listProxy.push(100)
// set 1 100
// set length 2
```

`property`是数组的下标，`value`则是下标所对应的值

可以看到 Proxy 内部会自动根据 `push` 操作自动推算出它应该所处的下标 -> 说白了，就是能自动推算出你要操作的是哪个下标！

同理，数组的其它一些操作方式，都是类似的！

以上就是 Proxy 对数组一个监视了！ -> 可以看到它的功能还是非常强大的！ -> 这一点，如果放到 `Object.defineProperty` 上去搞的话就会特别的麻烦！

3）优势 3：Proxy 是以非侵入的方式监管了对象的读写

Proxy 相比于`Object.deleteProperty`还有一点优势，那就是「Proxy」它是以非侵入的方式监管了整个对象的读写，换句话说，就是「**一个已经定义好的对象，我们不需要对对象本身去做任何的操作就可以监视到它内部成员的读写了**」

``` js
// 优势 3：Proxy 不需要侵入对象 
// --------------------------

// Proxy 方式更为合理
const person2 = {
  name: 'zce',
  age: 20
}

const personProxy = new Proxy(person2, {
  get (target, property) {
    console.log('get', property)
    return target[property]
  },
  set (target, property, value) {
    console.log('set', property, value)
    target[property] = value
  }
})

personProxy.name = 'jack'

console.log(personProxy.name)
```

而`Object.deleteProperty`这种姿势，就要求我们必须要通过特定的方式单独去定义对象当中那些需要被监视的属性，因此，对于一个已经存在的对象而言，我们想要去监视它的属性，那就需要去做很多额外的操作了

``` js
const person = {}

Object.defineProperty(person, 'name', {
  get () {
    console.log('name 被访问')
    return person._name
  },
  set (value) {
    console.log('name 被设置')
    person._name = value
  }
})
Object.defineProperty(person, 'age', {
  get () {
    console.log('age 被访问')
    return person._age
  },
  set (value) {
    console.log('age 被设置')
    person._age = value
  }
})

person.name = 'jack'

console.log(person.name)
```

如何体会到这个优势？ -> 在大量使用`Object.deleteProperty`的过程中，去慢慢体会 Proxy 的这个「非侵入」优势！

> Proxy 姿势，这代码显然要写得更少！

## ★Reflect


