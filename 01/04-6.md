### ✍️ Tangxt ⏳ 2021-06-28 🏷️ functional programming

# 04-6-函数组合概念、Lodash 中的组合函数、组合函数原理模拟

## ★概述

- `组合`看起来像是在饲养函数。你就是饲养员，选择两个有特点又遭你喜欢的函数，让它们结合，产下一个崭新的函数。
- 组合某种类型（如函数）的两个元素本就该生成一个该类型的新元素。把两个乐高积木组合起来绝不可能得到一个林肯积木
  
  ![乐高 -> 林肯](assets/img/2021-06-29-08-39-39.png)
  
- 尽管我们可以定义一个从左向右的版本，但是**从右向左执行更加能够反映数学上的含义**——是的，组合的概念直接来自于数学课本
- 所有的组合都有的一个特性，这个特性就是结合律（associativity），符合结合律意味着不管你是把 `g` 和 `h` 分到一组，还是把 `f` 和 `g` 分到一组都不重要
  - `var associative = compose(f, compose(g, h)) == compose(compose(f, g), h); // true`
  - `compose(toUpperCase, compose(head, reverse));`
  - `compose(compose(toUpperCase, head), reverse);`
- 关于如何组合，并没有标准的答案——我们只是以自己喜欢的方式搭乐高积木罢了。通常来说，最佳实践是**让组合可重用**，就像 `last` 和 `angry` 那样。如果熟悉 Fowler 的《[重构](https://martinfowler.com/books/refactoring.html)》一书的话，你可能会认识到这个过程叫做 “[extract method](https://refactoring.com/catalog/extractFunction.html)”——只不过不需要关心对象的状态
  
  ![组合](assets/img/2021-06-29-09-04-13.png)
  
- Pointfree style -> never having to say your data -> Love means never having to say you’re sorry -> 这意味着函数从不提及它们所操作的数据。First class functions, currying, 和 composition 都很好地结合在一起创造了这种风格。
  - `not pointfree because we mention the data: word` -> `const snakeCase = word => word.toLowerCase().replace(/\s+/ig,'_');`
  - `pointfree` -> `const snakeCase = compose(replace(/\s+/ig,'_'), toLowerCase);`
  - Pointfree 模式能够帮助我们**减少不必要的命名**，**让代码保持简洁和通用**。对于函数式代码来说，Pointfree 是一个很好的试金石（试金石是指一种可用来鉴别黄金的石块，矿物学名称为碧玄岩），因为它让我们知道我们有一些「可以从输入到输出的」小的函数，。 -> 例如，我们不能组合 `while` 循环。
- Debugging -> `var dasherize = compose(join('-'), toLower, trace("after split"), split(' '), replace(/\s{2,}/ig, ' '));` -> 插入的`trace`在手递手传输入给下一个小函数，而`trace`只是在`log`这次输入的是啥？

💡：Extract Function？

![Extract Function](assets/img/2021-06-29-09-05-24.png)

``` js
function printOwing(invoice) {
  printBanner();
  let outstanding  = calculateOutstanding();

  //print details
  console.log(`name: ${invoice.customer}`);
  console.log(`amount: ${outstanding}`);  
}

// Extract Method

function printOwing(invoice) {
  printBanner();
  let outstanding  = calculateOutstanding();
  printDetails(outstanding);

  function printDetails(outstanding) {
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
  }
}
```

💡：范畴论？

➹：[如何评价阮一峰老师的函数式编程/范畴论教程？ - 杨博的回答 - 知乎](https://www.zhihu.com/question/278267469/answer/401128713)

➹：[【函数式编程】范畴论完全装逼手册 / Grokking Monad_厚积薄发者，轻舟万重山-CSDN 博客](https://blog.csdn.net/reliveIT/article/details/82959858)

➹：[JS 函数式编程 - 函子和范畴论 - SegmentFault 思否](https://segmentfault.com/a/1190000016829296)

## ★函数式编程，Haskell，范畴论的关系

> 在我刚开学习函数式编程的时候，我对函数式编程的理解就是：函数式是非常简单的世界，只有普通数据和函数。其实函数式编程并没这么简单，如果函数式编程就是掌握使用函数那其实大家都是会函数式编程的。
> 
> 函数式编程远没这么简单，还有一个数学分支理论范畴论 (category theory) 在背后支持着它。函数式编程，Haskell，范畴论三者之间的关系大概是这样的。范畴论是支持函数式编程的理论之一，而 Haskell 是一门纯函数式语言。
> 
> 为什么使用范畴论呢？是这样的，范畴论主要关注组合 (composition)。**稍微资深一点的程序员就会发现，平时编程的时候，如果你能把程序切成很多小的模块，然后组合这些模块成为想要的程序是一个非常好的编程思路。所以组合，或者说分而治之，的思想是很重要的。因为人的大脑并不是万能的，一个模块如果过于复杂，维护起来就非常难，体现在编程上就是，我们开发进度越来越慢，开发功能的速度越来越接近 bug 产生的速度 O.O**。
> 
> ok，既然范畴论只是关于组合的理论，不过我们的早就用上模块化的范式了。比如面想对象编程不就是把程序分成很多个对象，然后组合对象吗。是的，不过这些模块化不够安全，各个模块之间很多情况下都是互相影响的（也就是说，模块不独立，测试的时候绕不开互相影响的其他模块）。而函数的组合，互相之间是不会影响的。在函数式编程中，最基本的组合是函数的组合，在 Haskell 一个非常基本的操作符 `.` , 就是用来组合函数的。这个 `.` 与我们上学时候学习的复合函数是一个东西，`(f . g)(x) = f(g(x))`。
> 
> 函数式编程，Haskell，范畴论这三个概念如果展开讲其实讲一天一个月都讲不完，所以暂时就讲到这里。看完这篇文章肯定对于这些概念还是比较模糊的，我还会继续写一些别的文章补充这方面的内容。

> 范畴论是关于组合的。把这个组合一般化后，其实文章也是可以组合的。一篇文章如果非常冗长，很大的可能性是这个文章涵盖了很多要讲的东西，这其实容易让人分散注意力。所以我决定尽可能的把所有文章都切得比较细，这样看起来也容易抓到重点。

➹：[函数式编程，Haskell，范畴论的关系 - 知乎](https://zhuanlan.zhihu.com/p/31508545)

➹：[category theory 简介_Zhe Hu的博客-CSDN博客](https://blog.csdn.net/weixin_43801661/article/details/84670359)

