### ✍️ Tangxt ⏳ 2021-06-13 🏷️ functional programming

# 04-4-纯函数概念、Lodash、纯函数的好处、副作用

## ★概述

- 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。
  - `slice` -> 纯的 -> 返回新数组
  - `splice` -> 不纯的 -> 嚼烂调用它的那个数组，然后再吐出来
- 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。
  - “作用”本身并没什么坏处。“副作用”的关键部分在于“副”。就像一潭死水中的“水”本身并不是幼虫的培养器，“死”才是生成虫群的原因。同理，副作用中的“副”是滋生 bug 的温床。
  - 只要是跟函数外部环境发生的交互就都是副作用
  - 这并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生 -> `functor` 和 `monad`可以让我们学习如何控制副作用，总之请尽量远离这些**阴险的函数**
- 函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。
  - 纯函数就是数学上的函数，而且是函数式编程的全部
- 纯函数对于其依赖必须要诚实，这样我们就能知道它的目的
  - 通过强迫“注入”依赖，或者把它们当作参数传递，我们的应用也更加灵活
  - `function(Db, Email, attrs){}`
- 面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林
- 引用透明性（referential transparency）
  - 如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。
  - **函数的返回值只依赖于其输入值，这种特性就称为引用透明性（referential transparency）**
- 等式推导（equational reasoning）
  - 用这种技术来分析代码
  - 所谓“等式推导”就是“一对一”替换，有点像在不考虑程序性执行的怪异行为（quirks of programmatic evaluation）的情况下，手动执行相关代码
  - 就是把`(56－2n)(120+6n)`推导成`12(28－n)(20+n)`这种形式 -> 说白了就是简化代码
- 我们可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）
- curry 是一种工具，没有这个工具，那么纯函数程序写起来就有点费力 -> 不得不玩杂耍似的通过到处传递参数来操作数据，而且还被禁止使用状态，更别说“作用”了。
- 函数式编程的无状态
  - 进去的一样……出来的必定一样
  - 进去过的东西不因进去过而改变 -> 数组进去了，没有变化的出来了

## ★纯函数概念
