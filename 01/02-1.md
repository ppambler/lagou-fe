### ✍️ Tangxt ⏳ 2021-06-01 🏷️ asynchronous

# 02-1-概述、同步模式、异步模式、回调函数

## ★概述

众所周知，目前主流的 JS 环境，都是以单线程模式去执行 JS 代码

JS 采用单线程模式工作的原因，这与它最早的设计初衷有关

最早的 JS 就是一门运行在浏览器端的脚本语言，其目的是为了实现页面上的动态交互，而实现页面交互的核心就是 DOM 操作，而这也就确定了它必须使用单线程模型，否则就会出现很复杂的线程同步问题

比如，假设 JS 当中有多个线程同时去工作，其中一个线程修改了某一个 DOM 元素，而另一个线程同时又删除了这个元素，那么此时浏览器就无法明确该以哪个线程的工作结果为准了，所以为了避免这种线程同步的问题，JS 从一开始就被设计为了单线程模式工作，而这也就成为了这门语言最为核心的特性之一

在这里，所谓的单线程指的是：

![单线程](assets/img/2021-08-17-11-58-12.png)

你可以想象成在浏览器内部，只有一个人按照我们的代码去执行任务，只有一个人意味着它同时只能执行一人任务，而有多个任务的话，就必须得排队等待着一个一个依次被完成……

![线程](assets/img/2021-08-17-12-06-17.png)

这种模式最大的优点就是更安全、更简单，而缺点也同样很明显，比如遇到一个特别耗时的任务，那么后边的任务都必须要排队等待这个任务的结束，而这也会导致整个程序的执行会被拖延、出现假死的情况

![耗时操作](assets/img/2021-08-17-12-12-11.png)

为了解决耗时任务阻塞执行的这种问题，JS 语言将任务的执行模式分成了两种：

- 同步模式（Synchronous）
- 异步模式（Asynchronous）

我们要重点的了解的是在 JS 中，异步编程相关的一些内容，主要包括以下这么几点：

![内容概括](assets/img/2021-08-17-12-15-57.png)

1. 同步模式和异步模式 -> 表现差异、各自存在的意义
2. JS 单线程如何实现异步模式 -> 也就是事件循环和消息队列
3. 总结一下 JS 当中几种异步编程的方法
4. 着重了解 ES2015 所提供的 Promise 异步编程方案，以及这个过程中牵扯到的宏任务/微任务队列的相关概念
5. 了解 ES2015 里边提供的 Generator 异步编程解决方案以及 ES2017 当中提供的 Async/Await 语法糖，让我们可以写出更扁平的异步代码

## ★同步模式

同步执行模式是什么？

> 指的是代码当中的任务依次执行，后一个任务必须等待前一个任务结束才能够开始执行 -> 程序的执行顺序跟我们代码的编写顺序是完全一致的，总之这种方式会比较简单

在单线程情况下，大多数任务都会以同步模式去执行，注意，这里同步的并不是同时执行，而是**排队执行**

以一段同步代码为例，分析一下它的具体执行过程

![同步代码](assets/img/2021-08-17-14-05-33.png)

第一行代码执行前：

![执行前](assets/img/2021-08-17-14-13-31.png)

第一行代码开始执行：

遇到函数调用，压入到调用栈当中去执行

![执行第一行代码](assets/img/2021-08-17-14-18-10.png)

弹出调用栈，意味着一个任务结束了 -> 继续往下执行

下两个任务都是函数的声明 -> 不管是函数的声明还是变量的声明，它都不会产生任何的调用，所以代码会继续往地往下走

`foo()` -> `foo`函数的调用：

![foo](assets/img/2021-08-17-14-45-39.png)

整段代码执行完毕：

![over](assets/img/2021-08-17-14-47-06.png)

> 似乎可以认为 -> 一条语句就是一个待执行的任务

Call Stack 只是一个更专业的说法，更通俗一点的解释就是 JS 在执行引擎当中维护了一个正在工作的工作表或者说**正在执行的一个工作表**

![工作表](assets/img/2021-08-17-15-08-46.png)

更准确一点的图：

![工作表](assets/img/2021-08-17-15-19-09.png)

在这个表里边会记录当前我们正在做的一些事情，当工作表当中所有任务全部被清空过后，那么这一轮的工作（今天的工作）就算是结束了

这是一个纯同步模式下的执行情况，所以这是特别容易的理解，毕竟它的**整个执行过程非常符合我们正常的阅读逻辑或者说是思考逻辑**

不过这种排队执行的机制，它也存在一个很严重的问题，那就是如果其中的某一个任务或者更具体一点来说就是其中的某一行代码，它执行的时间过长，那么它后边的任务就会被延迟，而我们把这种延迟称之为「**阻塞**」

这种「阻塞」对于用户而言就意味着界面会有**卡顿或者叫卡死**，所以就**必须要有异步模式去解决我们程序当中那些无法避免的耗时任务操作**，如浏览器端的 Ajax 操作或者在 Node.js 当中的大文件读写等，而这些都会需要使用到异步模式去执行，从而避免我们的代码被卡死

## ★异步模式

异步执行模式，不同于同步模式的执行方式，异步模式的 API 是不会去等待这个任务的结束才开始执行下一个任务

![异步模式](assets/img/2021-08-17-19-42-34.png)

对于耗时操作，它都是开启过后就立即完后执行下一个任务

耗时任务的后续逻辑，我们一般会通过回调函数的方式去定义，在内部我们这个耗时任务完成过后就会自动执行我们传入的回调函数

异步模式对于 JS 是非常重要的，因为如果没有这种模式的话，我们单线程的 JS 语言就无法同时处理大量耗时任务

而对于开发者而言，单线程模式下面的异步，它最大的难点就是「代码的执行顺序并不会像同步代码一样通用易懂，因为它的执行顺序相对来说会比较跳跃」，简单来说就是：

![执行顺序](assets/img/2021-08-17-19-48-43.png)

对于这个问题，很好解决 -> 理解+习惯 -> 即最好的办法就是**多看多练多思考**

分析这段包含异步调用代码在 JS 当中异步执行的过程：

![异步代码](assets/img/2021-08-17-19-56-28.png)

因为有异步调用的过程，这个执行流程相对来说会复杂一点，介绍到的东西会相对多一些

💡：第一行代码执行前

![执行前](assets/img/2021-08-17-20-01-37.png)

代码整体的执行情况，大致与我们前边所分析的同步模式情况相同，只不过遇到一些异步调用时会有一些差异

首先会加载整体代码 -> 在 Call Stack 加入一个匿名的全局调用 -> 依次执行每行代码

💡：开始执行第一行代码

对于同步代码`console.log()` -> 压栈 -> 执行 -> 打印 -> 执行完，弹栈

💡：遇到第一个异步调用`setTimeout`

![setTimeout](assets/img/2021-08-17-20-16-58.png)

`setTimeout`压栈，由于这个函数内部是异步调用的，所以我们需要关心它的内部环境到底做了什么事情，其内部 API 非常简单，就是在内部为`timer1`函数开启了一个倒计时器，单独把`timer1`放到里边去，注意，这里的倒计时器是单独工作的，并不会受我们当前的 JS 线程影响，从我们开始执行过后就已经开始倒数了 -> 倒数完过后会干啥？之后再说

开启一个倒计时器过后，对于`setTimeout`函数来讲，它的调用就已经完成了，所以代码会继续往下执行

💡：遇到第二个`setTimeout`

![setTImeout 2](assets/img/2021-08-18-09-56-58.png)

💡：完成整体的匿名调用

![调用](assets/img/2021-08-18-09-59-05.png)

这个时候调用栈已经没有工作了，此时`Event loop`就会发挥作用

Event loop 只做一件事情 -> 那就是**负责监听调用栈和消息队列**，一旦调用栈里边所有的任务都结束了，那么事件循环就会从消息队列当中取出第一个回调函数，然后压入到调用栈，只不过此时我们的消息队列是空的，什么都没有，所以执行就相当于是暂停下来了……

💡：两个倒计时器

之前开启倒计时器后，就没有管过`Web APIs`这个区域了，而是继续往下执行剩余的代码

这两个计时器谁先倒计结束，那么谁就先被放到消息队列的第一位

从`1.8s`和`1 s`来看，`timer2`在第一位

![timer2](assets/img/2021-08-18-10-08-25.png)

一旦消息队列当中发生了变化 -> 事件循环就会监听到，然后把消息队列的第一个`timer2`取出来，压入到调用栈，交给 JS 引擎去执行 `timer2` -> JS 引擎开始了新一轮的执行，其执行逻辑和之前第一轮是一样的

在执行`timer2`的过程中，又遇到了异步调用 -> 开启计时器 -> ……如此循环

![代码执行结束](assets/img/2021-08-18-10-14-56.png)

💡：形象化理解

如果调用栈是一个正在执行的工作表，那么消息队列就可以理解成代办的的工作表，而 JS 引擎会先去做完调用栈里边所有的任务，然后通过事件循环从消息队列当中再取一个任务继续去执行，以此类推

整个过程我们随时都可以往消息队列当中再去放入一些任务 -> 这些任务会在消息队列当中排队等待事件循环的召唤

---

以上就是异步调用在 JS 当中的实现过程以及它的一个基本原理，整个过程都是通过内部的消息队列和事件循环去实现的

注意，`Call Stack`、`Web APIs`、`Queue`这三块区域是独立了，有它们各自的 Time Run，如倒计时器开启了，就会开始倒计时了，根本就不会管调用栈和消息队列里边是什么情况

💡：一图胜千言

![一图胜千言](assets/img/2021-08-18-10-32-03.png)

注意：JS 确实是单线程的，但我们的浏览器并不是单线程的，更具体一点来说，通过 JS 调用的某些内部 API，它并不是单线程的，如倒计时器，它内部就会有一个单独的线程去负责倒数，在时间到了过后，就会将回调放入到消息队列 -> 也就是说，这样一件事情，它是由一个单独的线程去做的，我们说的单线程指的是执行我们代码的那个线程，它是一个线程啊！ -> 说白了，这些内部的 API，它们会用单独的线程去执行这些等待的操作，以生活为例，有些事情需要耗时这必然需要去等的，而等总得有一个人去等吧，而在代码里，只不过是不让 JS 线程去等罢了

再说一点，我们所说的同步也好，异步也罢，肯定不是指我们写代码的方式，而是：

![API](assets/img/2021-08-18-10-41-04.png)

- 对于同步模式的 API -> 它的特点就是这个任务执行完，代码才会继续往下走，如`console.log()`
- 对于异步模式的 API -> 下达这个任务开启过后的指令就会往下执行了，代码是不会在这一行等待任务结束的，如`setTimeout`

![API 是关键](assets/img/2021-08-18-10-48-57.png)

## ★回调函数

