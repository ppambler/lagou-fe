### ✍️ Tangxt ⏳ 2021-07-13 🏷️ functional programming

# 04-10-Folktale、Task 函子、Pointed 函子、IO 函子问题、Monad 函子、总结

## ★Folktale

函子可以帮我们控制副作用，进行异常处理，还可以处理异步任务

在异步操作中，很容易出现回调地狱，而使用 Task 函子可以避免出现回调嵌套……

因为异步任务的实现过于复杂，我们使用 folktale 这个库中所提供的 Task 函子来进行演示

[folktale](https://folktale.origamitower.com/) 一个标准的函数式编程库，和 lodash、ramda 不同的是，它里边没有提供很多功能性的函数，如 lodash、ramda 中都提供了很多数组和字符串操作相关的方法，但是，folktale 中只提供了一些跟函数式处理相关的操作，例如：`compose`、`curry` 等，还有一些函子 ，如`Task`、`Either`、`MayBe` 等

👇：先演示 folktale 这个库中的`compose`和`curry`使用姿势，之后再演示使用 Task 函子处理异步任务

1）compose、curry

安装`folktale`：

``` js
yarn add folktale
```

使用：

``` js
// folktale 中的 compose、curry
const { compose, curry } = require("folktale/core/lambda");
const { toUpper, first } = require("lodash/fp");

// 第一个参数是确定后边这个函数是要传几个参数，避免错误
let f = curry(2, (x, y) => {
  return x + y
})

console.log(f(1, 2)) // 3
console.log(f(1)(2)) // 3

// 也是右到左
let g = compose(toUpper, first);
console.log(g(["one", "two", "three"])); // 'ONE'
```

👇：演示 folktale 中的 Task 函子如何去处理异步任务

## ★Task 函子

folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的函子，如：

![folktale](assets/img/2021-07-15-13-17-11.png)

2.x 中，`task`是个函数（一个函数返回一个函子对象），而`1.x`则是个类（需要自己去`new`一个函子对象出来）！

![task](assets/img/2021-07-15-13-49-13.png)

> [Type: Task — Folktale 1.0 documentation](https://folktalegithubio.readthedocs.io/en/latest/api/data/task/Task.html#)、[folktale/data.task](https://github.com/folktale/data.task)

在这里以 2.3.2 来演示：

![folktale](assets/img/2021-07-15-13-27-31.png)

- `task`接收的函数必须固定一个参数`resolver` -> 这一点和 `Promise` 很像！
- `readFile`是`error`优先，数据置后…… -> 和`lodash/fp`联系上了
- 直接`readFile('package.json')`，不`run`，会返回一个`Task`函子 -> 它里边装的是一个匿名函数，被叫做`_computation` -> 可以看到这也是延迟求数据的 -> 当调用`run`时才会执行传给`task`的函数
- `listen`可以监听当前异步任务执行的状态（接收一个对象，有两个属性`onRejected`，`onResolved`） -> 用事件机制提供 -> 都用`on`开头
- 把`map`写在`listen`之前，相当于把两个函数组合起来暂存起来，等到`run`调用会把拿到的文件数据，然后传给组合函数去处理，最后再调用`onResolved` -> 这很像 `IO` 函子 -> 可简单理解成，这两个`map`里边的小函数就是一个小管道，文件数据从第一个`map`的管道开始流入，最后在`onResolved`这个管道输出

![Task](assets/img/2021-07-15-14-14-51.png)

**使用 `Task` 函子的时候，就不要去想它里边的实现机制了**，之前我们自己写函子，以此来了解函子内部的执行机制，而我们在开发的时候，直接使用就好了，不用去想`Task`函子内部是如何实现的！

看看它的执行流程：

![folktale 执行流程](assets/img/2021-07-15-13-41-39.png)

以上就是如何使用`Task`函子来执行异步任务

## ★IO 函子问题

