### ✍️ Tangxt ⏳ 2021-07-13 🏷️ functional programming

# 04-10-Folktale、Task 函子、Pointed 函子、IO 函子问题、Monad 函子、总结

## ★Folktale

函子可以帮我们控制副作用，进行异常处理，还可以处理异步任务

在异步操作中，很容易出现回调地狱，而使用 Task 函子可以避免出现回调嵌套……

因为异步任务的实现过于复杂，我们使用 folktale 这个库中所提供的 Task 函子来进行演示

[folktale](https://folktale.origamitower.com/) 一个标准的函数式编程库，和 lodash、ramda 不同的是，它里边没有提供很多功能性的函数，如 lodash、ramda 中都提供了很多数组和字符串操作相关的方法，但是，folktale 中只提供了一些跟函数式处理相关的操作，例如：`compose`、`curry` 等，还有一些函子 ，如`Task`、`Either`、`MayBe` 等

👇：先演示 folktale 这个库中的`compose`和`curry`使用姿势，之后再演示使用 Task 函子处理异步任务

1）compose、curry

安装`folktale`：

``` js
yarn add folktale
```

使用：

``` js
// folktale 中的 compose、curry
const { compose, curry } = require("folktale/core/lambda");
const { toUpper, first } = require("lodash/fp");

// 第一个参数是确定后边这个函数是要传几个参数，避免错误
let f = curry(2, (x, y) => {
  return x + y
})

console.log(f(1, 2)) // 3
console.log(f(1)(2)) // 3

// 也是右到左
let g = compose(toUpper, first);
console.log(g(["one", "two", "three"])); // 'ONE'
```

👇：演示 folktale 中的 Task 函子如何去处理异步任务

## ★Task 函子

folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的函子，如：

![folktale](assets/img/2021-07-15-13-17-11.png)

2.x 中，`task`是个函数（一个函数返回一个函子对象），而`1.x`则是个类（需要自己去`new`一个函子对象出来）！

![task](assets/img/2021-07-15-13-49-13.png)

> [Type: Task — Folktale 1.0 documentation](https://folktalegithubio.readthedocs.io/en/latest/api/data/task/Task.html#)、[folktale/data.task](https://github.com/folktale/data.task)

在这里以 2.3.2 来演示：

![folktale](assets/img/2021-07-15-13-27-31.png)

- `task`接收的函数必须固定一个参数`resolver` -> 这一点和 `Promise` 很像！
- `readFile`是`error`优先，数据置后…… -> 和`lodash/fp`联系上了
- 直接`readFile('package.json')`，不`run`，会返回一个`Task`函子 -> 它里边装的是一个匿名函数，被叫做`_computation` -> 可以看到这也是延迟求数据的 -> 当调用`run`时才会执行传给`task`的函数
- `listen`可以监听当前异步任务执行的状态（接收一个对象，有两个属性`onRejected`，`onResolved`） -> 用事件机制提供 -> 都用`on`开头
- 把`map`写在`listen`之前，相当于把两个函数组合起来暂存起来，等到`run`调用会把拿到的文件数据，然后传给组合函数去处理，最后再调用`onResolved` -> 这很像 `IO` 函子 -> 可简单理解成，这两个`map`里边的小函数就是一个小管道，文件数据从第一个`map`的管道开始流入，最后在`onResolved`这个管道输出

![Task](assets/img/2021-07-15-14-14-51.png)

**使用 `Task` 函子的时候，就不要去想它里边的实现机制了**，之前我们自己写函子，以此来了解函子内部的执行机制，而我们在开发的时候，直接使用就好了，不用去想`Task`函子内部是如何实现的！

看看它的执行流程：

![folktale 执行流程](assets/img/2021-07-15-13-41-39.png)

以上就是如何使用`Task`函子来执行异步任务

## ★Pointed 函子

这个函子我们一直在使用，一点都不陌生

Pointed 函子是实现了 `of` 静态方法的函子，我们之前所写的函子都是实现了`of`方法的，所以他们都是 Pointed 函子

我们之前说 `of` 方法是为了避免使用 `new` 来创建对象，即避免我们的代码看起来很面向对象，但是 `of` 方法更深层的含义是 -> 它是用来把值放到一个上下文 `Context` 中（把值放到容器中，使用 map 来处理值），然后我们在上下文中去处理我们的值

![value & context](assets/img/2021-07-15-18-57-20.png)

> input & placeholder

Pointer 函子对应的代码：

![Pointed 函子](assets/img/2021-07-15-19-05-49.png)

总之，Pointed 函子非常简单，就是一个概念而已 -> 一直在使用，从未刻意去称呼它……也就是说，你知不知道这个概念也没事儿……

## ★IO 函子问题

我们将要学习最后一个函子——Monad（单细胞），我们经常把它翻译成单子

但在学习 Monad 之前，我们先来演示 IO 函子中的一个问题

需求：模拟`cat`命令 -> 读取文件内容，并把这个内容给打印出来

思路：写两个函数 -> 读取函数+打印函数  -> 再把它们俩组合成一个`cat`函数

``` js
// IO 函子的问题
const fs = require('fs')
const fp = require('lodash/fp')

class IO {
  static of (value) {
    return new IO(function () {
      return value
    })
  }

  constructor (fn) {
    this._value = fn
  }

  map (fn) {
    return new IO(fp.flowRight(fn, this._value))
  }
}

// 读取文件时会引起副作用，因此会让这个函数变得不纯
// 所以我们在这儿不直接去读取文件，而是返回一个 IO 函子
let readFile = function (filename) {
  return new IO(function () {
    // 把读取文件这个过程延迟去执行了 -> 在这里同步读，好测试
    return fs.readFileSync(filename, 'utf-8')
  })
}

// 接收要打印的内容
let print = function (x) {
  return new IO(function () {
    // 打印内容，返回内容
    console.log(x)
    return x
  })
}

let cat = fp.flowRight(print, readFile)
// IO(IO(x))
let r = cat('package.json')._value()._value()
console.log(r)
```

执行流程：

![IO 函子](assets/img/2021-07-15-19-40-45.png)

> `IO(IO(x))`像是之前我想的把`data`传给 IO 函子 -> 实际应该是`IO(() => IO(x))`

读文件这个操作是最后一个`_value`做的，第一个`_value`会执行`print IO`函子的函数值，所以这个`x`是`readFile IO`函子，可不是`package.json`的内容 -> `print`的内容是`r`，即`console.log(fs.readFileSync('package.json', 'utf-8'))`

> 写组合函数时是：readFile -> print
> 
> 真正调用 IO 函子的值时是：print IO -> readFile IO

这里边存在的问题：

![IO 函子嵌套](assets/img/2021-07-15-20-05-46.png)

在调用嵌套函子中的函数时是非常不方便的 -> 需要写两次`._value()`

虽然这样写可以拿到数据，但这种 API 风格看起来是很不爽的 -> 所以我们想要把它改造一下，然，如何改造呢？

## ★Monad 函子

