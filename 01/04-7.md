### ✍️ Tangxt ⏳ 2021-06-30 🏷️ functional programming

# 04-7-函数组合-结合律、函数组合-调试、Lodash-fp 模块、Lodash-map 方法的小问题

## ★函数组合-结合律

函数组合满要满足一个特点——**结合律**（associativity）

啥意思？ -> 数学中的 [结合律](https://www.shuxuele.com/associative-commutative-distributive.html) 是啥意思，它就是啥意思

![结合律](assets/img/2021-06-30-10-04-22.png)

简单来说就是：

> 我们既可以把 `g` 和 `h` 组合，还可以把 `f` 和 `g` 组合，结果都是一样的

``` js
// 结合律（associativity）
let f = compose(f, g, h);
let associative = compose(compose(f, g), h) == compose(f, compose(g, h));
// true
```

👇：用 Lodash 里边的 API 演示这个结合律

![结合律](assets/img/2021-06-30-10-11-46.png)

这个结合律其实就是数学中的结合律 -> 先结合前两个数或者先结合后两个数 -> 结果都是一样的

## ★函数组合-调试

目前，我们可以使用组合解决一些简单的问题

那么问题来了，当我们使用函数组合的时候，如果函数执行的结果跟我们预期的不一致，那这个时候我们该如何调试呢？

![调试](assets/img/2021-06-30-17-36-48.png)

👇：演示如何调试组合函数

需求：`'NEVER SAY DIE' --> 'never-say-die'`

思路：根据空格分割它，小写化，再用`-`连接

用很多种做法，可以做到，如：

``` js
'NEVER SAY DIE'.split(' ').map((v,k)=>{ return v.toLowerCase() }).join('-') // "never-say-die"
```

但在这里我们先演示一个有 bug 的版本：

> 注意：在函数组合的时候 -> 需要的是一些只有一个参数的纯函数

Step 1：确定小函数

- `_.split`需要接收多个参数，我们要把它改造成只接受一个参数的函数，而且数据比需要放在最后一位，默认的`split`，数据是第一位，而分割符是第二位 -> 需要用柯里化
  
  ![split](assets/img/2021-06-30-19-19-19.png)
  
- `_.toLower`是单参数的函数，不需要柯里化它
- `_.join`需要两个参数 -> 第一个是数组，第二个是分隔符 -> 封装它，让这两个参数的位置交换一下，毕竟我们要最后传递数据

``` js
// _.split()
const split = _.curry((sep, str) => _.split(str, sep))

// _.toLower()
const join = _.curry((sep, array) => _.join(array, sep))
```

👇：把这些小函数组合成一个新的函数来满足我们的需求

Step 2：把小函数组合起来

![组合小函数](assets/img/2021-06-30-19-30-57.png)

可以看到输出结果跟我们预期的结果相差很远

所以这问题是出在哪儿呢？是`split`的问题？`toLower`的问题？还是`join`的问题？ -> 不知道，而且目前也不知道如何调试……

如何调试？

![debugger](assets/img/2021-06-30-20-27-17.png)

``` js
console.log([ 'NEVER', 'SAY', 'DIE' ].toString().toLowerCase())
console.log(Array.from('never,say,die'))
console.log(Array.from('never,say,die').join('-'))

// never,say,die
// [
//   'n', 'e', 'v', 'e',
//   'r', ',', 's', 'a',
//   'y', ',', 'd', 'i',
//   'e'
// ]
// n-e-v-e-r-,-s-a-y-,-d-i-e
```

如何解决这个 bug？ -> 让`toLower`的返回值是一个数组呗！ -> 使用`map`函数遍历，为每个元素`toLower`一下

做法：

`_.map` -> 需要接收两个参数（数组和`callback`） -> 柯里化它 -> 在组合时固定一个`callback`

![map](assets/img/2021-06-30-20-49-29.png)

> `array.map(function(currentValue, index, arr), thisValue)`

总之，我们通过`log`这个辅助函数，可以观察到每一个中间函数执行的结果

然而，现在还是有一个问题的，那就是如果组合的函数比较多，这中间结果就比较多了，这时候看`log`会分不清这个值是属于哪个中间函数的输出了！

定义一个`trace`函数：

![trace](assets/img/2021-06-30-20-59-35.png)

可以看到用了这个`trace`函数后，调试结果更清晰了 -> 其实如果有一个类似 Vue 调试工具就好了，我们不用写`trace`，就能通过小工具知道每个小函数的输出结果是什么了……

小结：

- Lodash 中的小函数符合我们平时使用函数的习惯，但是在用组合的过程中，我们不能这样直接的使用它们，所以我们对它们进行了改造 -> 也许你会感到很不方便，毕竟需要二次封装然后`curry`它们 -> Lodash 中提供的 `fp` 模块里边，也有这些小函数，我们在组合的时候，可以直接使用它们，无须二次封装再`curry`

## ★Lodash-fp 模块

