### ✍️ Tangxt ⏳ 2021-08-24 🏷️ Asynchronous

# 02-3-Generator 异步方案、Async 函数

## ★前言

1）Promise vs Callback

💡：定义一个`ajax`函数，让它既可以往`then`传回调，又可以往它第二个参数传回调？

``` js
function ajax(url, callback) {
  const executor = (resolve, reject) => {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(xhr.response)
      } else {
        reject(new Error(xhr.statusText))
      }
    }
    xhr.send()
  }

  if (typeof callback === 'function') {
    // support callback
    executor(
      res => callback(null, res),
      err => callback(err)
    )
    return undefined
  }

  return new Promise(executor)
}
```

测试代码：

![测试代码](assets/img/2021-08-24-15-08-37.png)

💡：Callback 的问题？

![Callback](assets/img/2021-08-24-15-09-38.png)

💡：如何解决回到地狱问题？

![Promise chain](assets/img/2021-08-24-15-11-19.png)

💡：如何解决异步代码不好阅读的问题？

![异步代码不好阅读](assets/img/2021-08-24-15-17-59.png)

💡：小结

![区别](assets/img/2021-08-24-15-16-36.png)

## ★Generator 异步方案（上）

> 回顾 Generator 函数

1）概述

相比于传统的回调姿势，Promise 去处理异步调用最大的优势就是可以通过链式调用解决回调嵌套过深的问题

使用 Promise 处理异步任务的串联执行，它的表现就是一个`then`然后处理一个异步调用，最终整体会形成一个任务的链条，从而实现所有任务的串联执行

![串联执行](assets/img/2021-08-24-15-02-00.png)

但是，这样写仍然会有大量的回调函数，虽然它们相互之间没有嵌套，但是它们还是没法达到我们传统同步代码的那种可读性

如果是传统同步代码姿势，那我们的代码可能就是这个样子：

![同步代码](assets/img/2021-08-24-15-03-22.png)

很明显这种方式去写我们的异步代码 -> 它是最简洁，也是最容易阅读和理解的

💡：微任务也是需要排队的？

![微任务](assets/img/2021-08-24-17-46-01.png)

👇：看看两种更优的异步编程写法

2）ES2015 提供的 Generator

之前已经简单了解过生成器函数的语法以及它的一些基本特点，在这里，就简单复习一下

💡：语法

![语法](assets/img/2021-08-24-18-57-53.png)

![参数](assets/img/2021-08-24-18-59-24.png)

> `next()`有返回值，而`yield`也有返回值，你给`next()`传的参数就是它的返回值，不传就是`undefined`值 -> `yield`相当于是暂停了，`yield`右边的值（站在`yield`这个门前的值）是`{value,done}`里边的`value`值，下一个`next`的参数，相当于是有一个值打破了`yield`这扇门，投入了`res`的怀抱
> 
> `generator.throw`同`next`一样，`res1`求值时，抛了个异常罢了

![参数值](assets/img/2021-08-24-19-13-04.png)

> 如果你给第二个`next`传了一个`new Error('xxx')`错误对象，那么这是不会把错误给抛出的，这会当作是一个普通的错误对象值赋值给`res`

- 首先，在普通函数基础之上多了一个`*`
  - 调用这个生成器函数并不会立即去执行这个函数，而是得到的一个生成器对象
  - 直到我们手动调用这个对象的`next`方法，这个函数的函数体才会开始执行
- 其次，在函数内部可以随时使用`yield`关键词，向外去返回一个值
  - 在`next`方法返回的对象当中去拿到这样一个返回的值，另外，返回的这个对象还有一个`done`属性，用来表示这个生成器是否已经全部执行完了
  - 而且，`yield`关键词并不会像`return`语句一样立即去结束这个函数的执行，它只是暂停这个生成器函数的执行，直到外界下一次调用生成器对象的`next`方法，才会继续从`yield`这个位置往下执行
- 另外，调用`next`方法时，传入了一个参数，如`bar`，那么这个参数会作为`yield`这个语句的返回值 -> 说白了，`yield 'foo'`是有返回值的（相当于是一个表达式），在`yield`的左边可以接收到这个值
- 还有，手动调用生成器对象的`throw`方法，该方法可以在生成器函数内部抛出一个异常 -> 它同`next`一样也会让生成器函数往下执行，不过它的作用是抛出一个异常

💡：`yield` 的意思？

![yield](assets/img/2021-08-24-19-42-22.png)

➹：[yield - JavaScript - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield)

---

理解了生成器函数的特点以及它的执行过程过后，下一步是看看如何使用 Generator 去管理我们的异步流程

## ★Generator 异步方案（中）